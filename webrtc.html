<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ns="http://www.w3.org/1999/xhtml">
  <head>
    <link href="./webrtc.css" rel="stylesheet" type="text/css" />

    <title>JSEP1 BRANCH - WebRTC 1.0: Real-time Communication Between
    Browsers</title>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />

    <!--
     === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline.

      To tag a new releas in git hub

          Once the version is checked in and ready to go, you tag it with (need
          to chance the 20110823 to correct date )

               git tag -a v20120323 -m "This is release 20120323"

         Tags are not transferred by default with the push so you have to
         add a - -tags parameter to the push so it looks like. Note you need to
         remoce the space between the - and -tag to make a double dash. 

              git push - -tags 

         or alternatively you can push just the new tag with 

              git push origin v20120323


      To generate the dated version of the specification:

           Open this doc in Mozilla. 

           Do a CTRL-ALT-SHIFT-S

           Select "XHMTL( source)" from dialog box. This will pop a new tab with
           generated version of the document.

           This will open a new tab with generated html. Copy and paste this to
           a new file. Note if you use Chrome or Safari, this step will not
           work. What will happen is the paste will have the original document,
           not what was displayed in the window that you did the copy on.

           Rename the new file to the correct day such as
           webrtc-broken-20111003.html then search for and edit the links for
           "This version" and "Previos version". Add the new file into CVS and
           check in. 

           Once everyone is happy, the webrtc-broken.html and
           webrtc-broken-20111003.html files can be copied to
           webrtc.html and webrtc-20111003.html
           respectively in the ../editor/. directory. 
    -->

    <script class="remove" src="ReSpec.js/js/respec.js" type="text/javascript">
      <!-- keep this comment -->
    </script>

    <script class="remove" src="webrtc.js" type="text/javascript">
      <!-- keep this comment -->
    </script>
  </head>

  <body>
    <section id="abstract">
      <p> This is not a product of the WebRTC WG - it is merely a document
      being used to discuss possible changes to the documents that WG is
      developing. Much of the text here is from the WG document.</p>

      <p>This document defines a set of APIs to represent streaming media,
      including audio and video, in JavaScript, to allow media to be sent over
      the network to another browser or device implementing the appropriate
      set of real-time protocols, and media received from another browser or
      device to be processed and displayed locally. This specification is
      being developed in conjunction with a protocol specification developed
      by the IETF RTCWEB group and an API specification to get access to local
      media devices developed by the Media Capture Task Force.</p>
    </section>

    <section id="conformance">
      <p> Implementations that use ECMAScript to implement the APIs defined in
      this specification must implement them in a manner consistent with the
      ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL]], as
      this specification uses that specification and terminology. </p>
    </section>

    <section id="sotd">
      <p>This document is not complete. It is subject to major changes and,
      while early experimentations are encouraged, it is therefore not
      intended for implementation. The API is based on preliminary work done
      in the WHATWG. The Web Real-Time Communications Working Group expects
      this specification to evolve significantly based on:</p>

      <ul>
        <li>The outcomes of ongoing exchanges in the companion RTCWEB group at
        IETF to define the set of protocols that, together with this document,
        will enable real-time communications in Web browsers.</li>

        <li>Privacy issues that arise when exposing local capabilities and
        local streams.</li>

        <li>Technical discussions within the group, on the data channel in
        particular.</li>

        <li>Experience gained through early experimentations.</li>

        <li>Feedback received from other groups and individuals.</li>
      </ul>
    </section>

    <section class="informative" id="intro">
      <h2>Introduction</h2>

      <p>There are a number of facets to video-conferencing in HTML covered by
      this specification:</p>

      <ul>
        <li>Representing a multimedia stream (video, audio, or both) from
        local devices (video cameras, microphones, Web cams) or from
        prerecorded files provided by the user.</li>

        <li>Connecting to remote peers using NAT-traversal technologies such
        as ICE, STUN, and TURN.</li>

        <li>Sending the locally-produced streams to remote peers and receiving
        streams from remote peers.</li>

        <li>Sending arbitrary data directly to remote peers.</li>
      </ul>

      <p>This document defines the APIs used for these features. This
      specification is being developed in conjunction with a protocol
      specification developed by the <a
      href="http://datatracker.ietf.org/wg/rtcweb/">IETF RTCWEB group</a> and
      an API specification to get access to local media devices developed by
      the <a href="http://www.w3.org/2011/04/webrtc/">Media Capture Task
      Force</a>.</p>
    </section>


    <section>
      <h2>Peer-to-peer connections</h2>

      <p>A <code>
          <a>PeerConnection</a>
        </code> allows two users to communicate directly, browser to browser.
      Communications are coordinated via a signaling channel provided by
      script in the page via the server, e.g. using
      <code>XMLHttpRequest</code>.</p>

      <p>Calling <code>new <a>PeerConnection</a>(<var>configuration</var>
      )</code> creates a <code>
          <a>PeerConnection</a>
        </code> object.</p>

      <p>The <var>configuration</var> has the information to find and access the
       [[!STUN]] and [[!TURN]] servers. There may be multiple servers of
       each type and any TURN server also acts as a STUN server. </p>

     

      <p>A <code>
          <a>PeerConnection</a>
        </code> object has an associated a <dfn
      id="peerconnection-ice-agent"><code>PeerConnection</code> ICE
      Agent</dfn>, and a <dfn
      id="peerconnection-readiness-state"><code>PeerConnection</code>
      readiness state</dfn>. These are initialized when the object is
      created.</p>

      <p>When the <dfn id="dom-peerconnection">
          <code>PeerConnection()</code>
        </dfn> constructor is invoked, the user agent MUST run the following
      steps. This algorithm has a synchronous section (which is triggered as
      part of the event loop algorithm). Steps in the synchronous section are
      marked with ⌛.</p>

      <ol>
        <li>
          <p>Create an ICE Agent and let <var>connection</var>’s <a
          href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
          Agent</a> be that ICE Agent and provide it the STUN and TURN servers
          from the configuration array. The [[!ICE]] will proceed with
        gathering as soon as the IceTransports constraint is not set to
        "none". At this point the ICE Agent will not know how many host
        candidates it needs to allocate but it can make a reasonable assumption
        and as the PeerConnection object gets more information, it can adjust
        the number of host candidates in use. </p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          readiness state</a> to <code>
              <a href="#widl-PeerConnection-NEW">"new"</a>
            </code>. </p>
        </li>

        <li>
          <p>Set <var>connection</var>’s <a
          href="#peerconnection-readiness-state"><code>PeerConnection</code>
          ice state </a> to <code>
              <a href="#widl-PeerConnection-NEW">"new"</a>
            </code>. </p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-localStreams">
              <a href="#widl-PeerConnection-localStreams">localStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Let <var>connection</var>’s <code
              title="dom-PeerConnection-remoteStreams">
              <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
            </code> attribute be an empty read-only <code>
              <a>MediaStream</a>
            </code> array. </p>
        </li>

        <li>
          <p>Return <var>connection</var>, but continue these steps
          asynchronously.</p>
        </li>

        <li>
          <p>Await a stable state. The synchronous section consists of the
          remaining steps of this algorithm. </p>
        </li>

        <li>
          <p>If the ice state is set to "new", it MUST queue a task to start
          gathering ICE address and set the ice state to "gathering".</p>
        </li>
      </ol>

      <p> During the lifetime of the PeerConnection object, the following
      procedures are followed: </p>

      <ol>
        <li>
          <p> If the ICE Agent finds a candidates that forms a valid
          connection, the ICE state is changed to "connected". </p>
        </li>

        <li>
          <p> If the ICE Agent finishes checking all candidates, if a
          connection has been found, the ice state is changed to "completed"
          and if not connection has been found it is changed to "failed".
          </p>
        </li>

        <li>
          <p> If the iceState is "connected" or "completed" and both the local
          and remote session descriptions are set, the peerState is set to "active". </p>
        </li>

        <li>
          <p> If the iceState is "failed", a task is queued to calls the
          close method. </p>
        </li>

        <li>
          <p> The close method will stop all ICE process and change the
          iceState to "closed". </p>
        </li>
      </ol>

      <p>User agents negotiate the codec resolution, bitrate, and other media
      parameters. User agents are encouraged to initially negotiate for the
      maximum resolution of a video stream. For streams that are then rendered
      (using a <code>video</code> element), user agents are encouraged to
      renegotiate for a resolution that matches the rendered display size.</p>

      <p class="note">Starting with the native resolution means that if the Web
      application notifies its peer of the native resolution as it starts
      sending data, and the peer prepares its <code>video</code> element
      accordingly, there will be no need for a renegotiation once the stream is
      flowing.</p>

      <p>All SDP media descriptions for RTP flows represented by <code>
          <a>MediaTrack</a>
        </code> objects MUST include a label attribute ("<code
      title="">a=label:</code>") whose value is the value of the <code>
          <a>MediaStream</a>
        </code> object's <code title="dom-MediaStream-label">
          <a href="#dom-mediastream-label">label</a>
        </code> attribute. [[!SDP]] [[!SDPLABEL]]</p>

      <p><a href="#peerconnection"><code>PeerConnection</code>s</a> MUST not
      generate any candidates for media streams whose media descriptions do
      not have a label attribute ("<code>a=label:</code>"). [[!ICE]] [[!SDP]]
      [[!SDPLABEL]]  (Note: CJ - I have no idea why this is here) </p>

      <p> The word "components" in this context refers to an RTP media flow and
      does not have anything to do with hose [[ICE]] uses the term "component". </p>
      
      <p>When a user agent has reached the point in the media negotiation
      where a <code>
          <a>MediaStream</a>
        </code> can be created to represent incoming components, the user
      agent MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> expecting this media.</p>
        </li>

        <li>
          <p>Create a <code>
              <a>MediaStream</a>
            </code> object to represent the media stream. Set its <code>
              <a href="#dom-mediastream-label">label</a>
            </code> attribute to the value of the SDP Label attribute for that
          component's media stream.</p>
        </li>

        <li>
          <p>Run the following steps for each component in the media
          stream.</p>

          <ol>
            <li>
              <p>Create a <code>
                  <a>MediaStreamTrack</a>
                </code> object <var>track</var> to represent the
              component.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>audio</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-audiotracks">audioTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>

            <li>
              <p>If <var>track's</var> <code>
                  <a href="#dom-mediastreamtrack-kind">kind</a>
                </code> attribute equals "<code>video</code>", add it to the
              <code>
                  <a>MediaStream</a>
                </code> object's <code>
                  <a href="#dom-mediastream-videotracks">videoTracks</a>
                </code> <code>
                  <a>MediaStreamTrackList</a>
                </code> object.</p>
            </li>
          </ol>

          <p class="note">The internal order in the <code>
              <a>MediaStreamTrackList</a>
            </code> objects on the receiving side should reflect the order on
          the sending side. One way to enforce this is to specify the order in
          the SDP.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Add the newly created <code>
                  <a>MediaStream</a>
                </code> object to the end of <var>connection</var>’s <code
                  title="dom-PeerConnection-remoteStreams">
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-addstream">
                  <a href="#event-mediastream-addstream">addstream</a>
                </code> with the newly created <code>
                  <a>MediaStream</a>
                </code> object at the <var title="">connection</var>
              object. </p>
            </li>
          </ol>
        </li>
      </ol>

      <p>When a user agent has negotiated media for a component that belongs
      to a media stream that is already represented by an existing <code>
          <a>MediaStream</a>
        </code> object, the user agent MUST associate the component with that
      <code>
          <a>MediaStream</a>
        </code> object.</p>

      <p>When a <a href="#peerconnection">
          <code>PeerConnection</code>
        </a> finds that a stream from the remote peer has been removed (its
      port has been set to zero in a media description sent on the signaling
      channel), the user agent MUST follow these steps:</p>

      <ol>
        <li>
          <p>Let <var>connection</var> be the <code>
              <a>PeerConnection</a>
            </code> associated with the stream being removed.</p>
        </li>

        <li>
          <p>Let <var>stream</var> be the <code>
              <a>MediaStream</a>
            </code> object that represents the media stream being removed, if
          any. If there isn't one, then abort these steps.</p>
        </li>

        <li>
          <p>By definition, <var>stream</var> is now <a>finished</a>.</p>

          <p class="note">A <span title="concept-task">task</span> is thus
          <span title="queue a task">queued</span> to update <var>stream</var>
          and fire an event.</p>
        </li>

        <li>
          <p>Queue a task to run the following substeps:</p>

          <ol>
            <li>
              <p>If the <var>connection</var>’s <a
              href="#peerconnection-readiness-state"><code>PeerConnection</code>
              readiness state</a> is <code>
                  <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                </code> (3), abort these steps.</p>
            </li>

            <!-- close() was probably called just before this
     task ran -->

            <li>
              <p>Remove <var>stream</var> from <var>connection</var>’s <code>
                  <a
                  href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
                </code> array.</p>
            </li>

            <li>
              <p><a href="#fire-a-stream-event">Fire a stream event</a> named
              <code title="event-MediaStream-removestream">
                  <a href="#event-mediastream-removestream">removestream</a>
                </code> with <var title="">stream</var> at the
              <var>connection</var> object.</p>
            </li>
          </ol>
        </li>
      </ol>

      <p>The task source for the <span title="concept-task">tasks</span>
      listed in this section is the networking task source.</p>

      <p>If a <code>
          <a>PeerConnection</a>
        </code> object is <a title="consumer">consuming</a> a <code>
          <a>MediaStream</a>
        </code> and a track is added to one of the stream's <code>
          <a>MediaStreamTrackList</a>
        </code> objects, by, e.g., the <code>
          <a href="#dom-mediastreamtracklist-add">add()</a>
        </code> method being invoked, the <code>
          <a>PeerConnection</a>
        </code> object MUST add a media component for that track the next time
      the user agent <span title="provide a stable   state">provides a stable
      state</span>. The user agent MUST also remove a media component in same
      way.</p>

      <p>If something in the browser changes that causes the <code>
      <a>PeerConnection</a> </code> object needs to initiate a new session
      descipriton negotiation, an <code> <a
       href="#event-renegotiation">renegotiationneeded</a> </code> event is
      fired at the <code> <a>PeerConnection</a> </code> object.  </p>
      
      <p class="warning">To prevent network sniffing from allowing a fourth
      party to establish a connection to a peer using the information sent
      out-of-band to the other peer and thus spoofing the client, the
      configuration information SHOULD always be transmitted using an
      encrypted connection.</p>

      <section>
      <h3>PeerConnection</h3>
      
      <p> The general operation of the PeerConnection is described in
      [[RTCWEB-JSEP]]. </p>

       

      
      <section><h3>SdpType</h3>

          <p> The SdpType enums serve as arguments to setLocalDescription and
          setRemoteDescription. They provide information as to how the SDP
          should be handled. </p>

      <pre> enum SdpType { "offer", "pranswer",  "answer" } </pre>
      <!-- <dl class='idl' title='enum SdpType { "offer", "pranswer",  "answer" }'> </dl>-->

      <dl>
        <dt>
          <code title="widl-SdpType-offer">
          <a href="#widl-SdpType-offer">"offer"</a>
          </code>
        </dt>
        
        <dd>
          <p> An SdpType of "offer" indicates that a description should be
          treated as an [[!SDP]] offer. </p>
        </dd>
        
        <dt>
          <code title="widl-SdpType-pranswer">
          <a href="#widl-SdpType-pranswer">"pranswer"</a>
          </code>
        </dt>
        
        <dd>
          <p> An SdpType of "pranswer" indicates that a description should
          be treated as an [[!SDP]] answer, but not a final answer. A
          description used as a SDP "pranswer" may be applied as a
          response to a SDP offer, or an update to a previously sent SDP
          "pranswer". </p>
        </dd>
        
        <dt>
              <code title="widl-SdpType-answer">
          <a href="#widl-SdpType-answer">"answer"</a>
          </code>
        </dt>
        
        <dd>
          <p> An SdpType of "answer" indicates that a description should
          be treated as an [[!SDP]] final answer, and the offer-answer
          exchange should be considered complete. A description used as a
          SDP answer may be applied as a response to a SDP offer, or an
          update to a previously send SDP "pranswer". </p>
        </dd>
        
      </dl>
      </section>

      <section>
      <h3> SessionDescription Class </h3>
      
      <dl title='interface SessionDescription' class='idl'>  

        <dt>attribute SdpType type</dt>
        <dd>What type of SDP this SessionDescription represents.</dd>
        
        <dt>attribute DomString sdp</dt>
        <dd>The string representation of the SDP [[!SDP]]</dd>
            
      </dl>
      </section>
      
      <section>
      <h3> SessionDescriptionCallback </h3>

      <pre> callback SessionDescriptionCallback = void (SessionDescription sdp) </pre>
      <dl>
        <!-- dl title='callback SessionDescriptionCallback = void' class='idl' -->
          
        <dt>SessionDescription sdp</dt>
        <dd>The object representation of the SDP [[!SDP]]</dd>
      </dl>
      </section>

      <section>
      <h3> ErrorCallback </h3>
      
      <pre> callback ErrorCallback = void (DomString errorInformation) </pre>
      <dl>
        <!--  dl title='callback ErrorCallback = void' class='idl' -->
        
        <dt>DomString errorInformation</dt>
        <dd>Information about what went wrong</dd>
      </dl>

      <p> TODO: Open Issue: should this be defined as event like
      NavigatorUserMediaErrorCallback in getusermedia </p>
      
      </section>
      
      <section>
      <h3> PeerState Enum </h3>
      <pre>enum PeerState { "new" "opening", "active", "closing", "closed" }</pre>
      <!--  <dl  title='enum PeerState { "new" "opening","active", "closing", "closed" }' class='idl' > </dl> -->
      <dl>
        <dt>
          <code title="widl-PeerConnection-NEW">
          <a href="#widl-PeerConnection-NEW">"new"</a>
          </code>
        </dt>
        <dd>
          The object was just created, and no networking has yet
          occurred.
        </dd>
          
        <dt>
          <code title="dom-PeerConnection-NEGOTIATING">
          <a href="#widl-PeerConnection-OPENING">"opening"</a>
          </code>
        </dt>
        <dd>The user agent is attempting to establish an connection with
          the ICE Agent and waiting for local and remote SDP to be set. (Open
          Issue: do we need more states between "opening" and "active")
        </dd>
        
        <dt>
          <code title="dom-PeerConnection-ACTIVE">
          <a href="#widl-PeerConnection-ACTIVE">"active"</a>
          </code>
        </dt>
        <dd>The ICE Agent has found a connection both the local and remote
          SDP have been set. It is possible for media to flow.
        </dd>
          
        <dt>
          <code title="dom-PeerConnection-CLOSING">
          <a href="#widl-PeerConnection-CLOSED">"closing"</a>
          </code>
        </dt>
        <dd> The <code>
          <a>PeerConnection</a>
          </code> object is terminating all media and is in the process of
          closing the connection.
        </dd>
          
        <dt>
          <code title="dom-PeerConnection-CLOSED">
          <a href="#widl-PeerConnection-CLOSED">"closed"</a>
          </code>
        </dt>
        <dd>
          The connection is closed.
        </dd>
        
      </dl>
      </section>

      <section>
      <h3> IceState Enum </h3>
      <pre> enum IceState { "new" "gathering", "waiting", "checking", "connected", "completed","failed", "closed" }</pre>
      <!-- <dl class='idl' title='enum IceState { "new" "gathering", "waiting", "checking", "connected", "completed","failed", "closed"}'> </dl> -->
     
          <dl>
            <dt>
              <code title="widl-PeerConnection-NEW">
                <a href="#widl-PeerConnection-NEW">"new"</a>
              </code>
            </dt>

            <dd>The PeerConnection object was just created, and no networking
            has yet occurred.</dd>

            <dt>
              <code title="dom-PeerConnection-GATHERING">
                <a href="#widl-PeerConnection-ICE_GATHERING">"gathering"</a>
              </code>
            </dt>

            <dd>The ICE Agent is attempting to gather addresses.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_WAITING">
                <a href="#widl-PeerConnection-ICE_WAITING">"waiting"</a>
              </code>
            </dt>

            <dd>The ICE Agent is not gathering any addresses and is waiting
            for candidates from the other side before it can start
            checking.</dd>

            <dt>
              <code title="dom-PeerConnection-CHECKING">
                <a href="#widl-PeerConnection-ACTIVE">"checking"</a>
              </code>
            </dt>

            <dd>The ICE Agent is checking candidates but has not yet found a
            connection. In addition to checking, it may also still be gathering. </dd>

            <dt>
              <code title="dom-PeerConnection-CONNECTED">
                <a href="#widl-PeerConnection-CLOSED">"connected"</a>
              </code>
            </dt>

            <dd>The ICE Agent has found a connection but is still checking
            other candidates to see if there is a better connection. It may also still be gathering. </dd>

            <dt>
              <code title="dom-PeerConnection-COMPLETED">
                <a href="#widl-PeerConnection-CLOSED">"completed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has finished gathering and checking and found a
            connection.</dd>

            <dt>
              <code title="dom-PeerConnection-ICE_FAILED">
                <a href="#widl-PeerConnection-CLOSED">"failed"</a>
              </code>
            </dt>

            <dd>The ICE Agent is finished checking all candidates and failed
            to find a connection.</dd>

            <dt>
              <code title="dom-PeerConnection-CLOSED">
                <a href="#widl-PeerConnection-CLOSED">"closed"</a>
              </code>
            </dt>

            <dd>The ICE Agent has shut down and is no longer responding to
            STUN requests.</dd>
          </dl>
       
        </section>

            <section>
        <h3> IceCandidate Type </h3>       
        <dl class='idl' title='interface IceCandidate'>

          <dt> attribute DomString candidate </dt>
          
          <dd> This carries the candidate-attribute as defined in section 15.1 of
          [[!ICE]]. ( Note - need to add more information to allow this to match
          to correct m line ).  </dd>
          
        </dl>
        </section>

          <section>
      <h3> IceCandidateCallback </h3>
      
      <pre> callback IceCandidateCallback = void (IceCandidate candidate) </pre>
      <dl>
        <!--  dl title='callback IceCandidateCallback = void' class='idl' -->
        
        <dt>IceCandidate candidate</dt>
        <dd>The new ICE candidate. </dd>
      </dl>
      </section>
      
        <section>
        <h3> Configuration Type </h3>       
        <dl class='idl' title='interface Configuration'>

          <dt> attribute DomString servers[][]</dt>
          
          <dd>

           The Configuration type is a array of pairs where each pair is an
            array where the first element is a stun or turn URIs as defined in
            [[!STUN-URI]] and [[!TURN-URI]]. If the first element of the pair is
            TURN URI, then the second element of the pair is the credential to
            use with that TURN server.
          </dd>
          
        </dl>

        <p> In network topologies with multiple layers of NATs, it is
          desirable to have a STUN servers between every layer of NATs in addition
          to the TURN servers to minimize the number peer to peer network
          latency. </p>

         <p>An example configuration object is:</p>

      <dl>
        <dt>
          <code> { servers:[ ["stun:stun.example.net"] ,
          ["turn:user@turn.example.org","myPassword"] ]} </code>
        </dt>
      </dl>
      
        </section>

        <section>
            <h3>PeerConnection Interface</h3>

        <p> Open Issue: should we collapse some of these functions a single
        "processRemoteSignal" method? </p>
    
        <dl class="idl"
            title="[Constructor (Configuration configuration,optional
           MediaConstraints constraints)] interface PeerConnection">

       


              <dt>void getCapabilities ( SessionDescriptionCallback
              successCallback )</dt>

          <dd>
            <p> The getCapabilities method generates a blob of SDP that contains a
            RFC offer that represets the most optimist view on the capabilities of the
            media system. It does not reserver any resources, ports, or other
            state but is meant to provide a way to discover the types of
            capabilities of the browser including which codecs may be
            supported. The SDP should have any ports set to 0 (Open Issue:
            should this be 9?). Other values that would allocate state can be
            set to static, unusable values. It should include the SDP for media
            stream for each media type the browser supports along with all the
            codecs that are supported. It does not matter if any streams have
            been added to the PeerConnection object.  </p>
            <p>
            TODO - discuss privacy implications. 
            </p>
        </dd>



        
          <dt>void createOffer ( SessionDescriptionCallback successCallback,
            optional ErrorCallback failureCallback,
            optional MediaConstraints constraints)</dt>

          <dd>
            <p> The createOffer method generates a blob of SDP that contains a
            RFC offer with the supported configurations for the session,
            including descriptions of the local MediaStreams attached to this
            PeerConnection, the codec/RTP/RTCP options supported by this
            implementation, and any candidates that have been gathered by the
            ICE Agent. The constraints parameter may be supplied to provide
            additional control over the offer generated. </p>

            <p> As an offer, the generated SDP will contain the full set of
            capabilities supported by the session (as opposed to an answer,
            which will include only a specific negotiated subset to use); for
            each SDP line, the generation of the SDP must follow the appropriate
            process for generating an offer. In the event createOffer is called
            after the session is established, createOffer will generate an offer
            that is compatible with the current session, incorporating any
            changes that have been made to the session since the last complete
            offer-answer exchange, such as addition or removal of streams. If no
            changes have been made, the offer will be include the capabilities
            of the current local description as well as any additional
            capabilities that could be negotiated in an updated offer. </p>

            <p> Session descriptions generated by createOffer MUST be
            immediately usable by setLocalDescription without causing an error
            as long as setLocalDiscription is called within the successCallback
            function. If a system has limited resources (e.g. a finite number of
            decoders), createOffer needs to return an offer that reflects the
            current state of the system, so that setLocalDescription will
            succeed when it attempts to acquire those resources. The session
            descriptions MUST remain usable by setLocalDescription without
            causing an error until at least end of the successCallback
            function. Calling this method is needed to get the ICE user name
            fragment and password. </p>

            <p> The failureCallback will be called if the system can not
            generate an appropriate offer given the state of the PeerConnection. </p>
            
            <p> A TBD exception is thrown if the constraints parameter is
            malformed. </p>

            <p> To Do: Discuss privacy aspects of this from a finger printing
        point of view - it's probably around as bad as access to a canvas :-)
        </p>

         </dd>


            
          <dt>void createAnswer (SessionDescriptionCallback offer,
            SessionDescriptionCallback successCallback,
            optional ErrorCallback failureCallback,
            optional MediaConstraints constraints,
            optional Boolean createProvisionalOffer=false)</dt>

          <dd>
            <p>The createAnswer method generates a [[!SDP]] answer with the
            supported configuration for the session that is compatible with
            the parameters supplied in offer. Like createOffer, the returned
            blob contains descriptions of the local MediaStreams attached to
            this PeerConnection, the codec/RTP/RTCP options negotiated for
            this session, and any candidates that have been gathered by the
            ICE Agent. The constraints parameter may be supplied to provide
            additional control over the generated answer. </p>

            <p> As an answer, the generated SDP will contain a specific
            configuration that, along with the offer, specifies how the media plane should be
            established. The generation of the SDP must
            follow the appropriate process for generating an answer or
            provisional answer. </p>

            <p> Session descriptions generated by createAnswer must be
            immediately usable by setLocalDescription without generating an
            error if setLocalDescription is called from the successCallback
            function. Like createOffer, the returned description should reflect
            the current state of the system. The session descriptions MUST
            remain usable by setLocalDescription without causing an error until
            at least the end of the successCallback function. Calling
            this method is is needed to get the ICE user name fragment and
            password. Provisional offers, as described in [[RTCWEB-JSEP]], are
            created if and only if the createProvisionalOffer flag is true. </p>

            <p> The failureCallback will be called if the system can not
            generate an appropriate answer given the offer. </p>
            
            <p> A TBD exception is thrown if the constraints parameter is
            malformed. </p>
            
          </dd>


       
          <dt>void setLocalDescription (SdpType action, SessionDescription sdp)</dt>

          <dd>
            <p> The setLocalDescription method instructs the PeerConnection to
            apply the supplied [[!SDP]] blob as the local offer or answer. The
            type parameter indicates whether the blob should be processed as
            an offer, provisional answer, or final answer. </p>

            <p> This API changes the local media state; among other things, it
            sets up local resources for receiving and decoding media. In order
            to successfully handle scenarios where the application wants to
            offer to change from one media format to a different, incompatible
            format, the PeerConnection must be able to simultaneously support
            use of both the old and new local descriptions (e.g. support
            codecs that exist in both descriptions) until a final answer is
            received, at which point the PeerConnection can fully adopt the
            new local description, or roll back to the old description if the
            remote side denied the change. </p>
            
            <p> Open issues: how to indicate to roll back? </p>

            <p> To Do: specify what parts of the SDP can be changed  between the
            createOffer and setLocalDescription </p>

            <p>Changes to the state of media transmission will occur when
            a final answer is successfully applied. </p>

            <p> A TBD exception is thrown if sdp is invalid. A TBD exception
            is thrown if there are insufficient local resources to apply the
            sdp. </p>

            <p> Open Issues: for setLocal and setRemote, discuss how to return
          erro codes and if they need to be asynchronous. </p>
            
          </dd>
 
          <dt>readonly attribute SessionDescription localDescription</dt>

          <dd>
            <p> The localDescription method returns a copy of the current
           the SessionDescription that was most recently passed
            to setLocalDescription, plus any local candidates that have been
            generated by the ICE Agent since then. </p>

            <p> A null object will be returned if the local description has
            not yet been set. </p>
          </dd>



          <dt>void setRemoteDescription (SdpType action, SessionDescription sdp)</dt>

          <dd>
            <p> The setRemoteDescription method instructs the PeerConnection
            to apply the supplied [[!SDP]]. As in setLocalDescription, the
            action parameter indicates how the blob should be processed. This
            API changes the local media state; among other things, it sets up
            local resources for sending and encoding media. </p>

            <p> Changes to the state of media transmission will occur
            when a final answer is successfully applied. </p>

            <p> A TBD exception is thrown if the sdp parameter is invalid. A
            TBD exception is thrown if there are insufficient local resources
            to apply the SDP. </p>
          </dd>

          <dt>readonly attribute SessionDescription remoteDescription</dt>

          <dd>
            <p> The remoteDescription method returns a copy of the current
            remote the SessionDescription that was most recently
            passed to setRemoteDescription, plus any remote candidates that
            have been supplied via addIceCandidate since then. </p>

            <p> A null object will be returned if the remote description has
            not yet been set. </p>
          </dd>


          
          <dt>readonly attribute PeerState readyState</dt>

          <dd>
            <p>The <dfn id="dom-peerconnection-readystate">
                <code title="">readyState</code>
              </dfn> attribute MUST return the <code>
                <a>PeerConnection</a>
              </code> object's <a
            href="#peerconnection-readiness-state"><code>PeerConnection</code>
            readiness state</a>. </p>
          </dd>

          <dt>void updateIce (optional Configuration configuration,
            optional MediaConstraints constraints,
            optional Boolean restart=false)</dt>

          <dd> <p> The updateIce method restarts or updates the ICE Agent process
            of gathering local candidates and pinging remote candidates. If
            there is a mandatory constraint called "IceTransports" it will
            control which how the ICE engine can act. This can be used to limit
            the use to TURN candidates by a callee to avoid leaking location
            information prior to the call being accepted. </p>

            <p> This call may result in a change to the state of the ICE
            Agent, and may result in a change to media state if it results in
            connectivity being established. </p>

            <p> If the restart parameter is set to true, the ICE state machine
            discards all candidates it has gathered, allocates new ports for the
            host candidates, and restarts ICE as if there had been no previos
            ICE session. Applications can use this to reset all ICE negotiation
            when something has gone terribly wrong.  </p>

            <p> A TBD exception will be thrown if constraints parameter is malformed.
            </p>
            
          </dd>

          <dt>void addIceCandidate (IceCandidate candidate)</dt>

          <dd> <p>The addIceCandidate method provides a remote candidate to the
            ICE Agent, which will be added to the remote
            description. Connectivity checks will be sent to the new candidates
            as long as the
            "media-enum-relay-only" constraint is not set to "none". This call will result in a
            change to the state of the ICE Agent, and may result in a change to
            media state if it results in different connectivity being established.  </p>

            <p> A TBD exception will be thrown if candidate parameter is
            malformed. </p>
          </dd>

          <dt>readonly attribute IceState iceState</dt>

          <dd>
            <p>The <dfn id="dom-peerconnection-icestate">
                <code>iceState</code>
              </dfn> attribute MUST return the state of the <a
            href="#peerconnection-ice-agent"><code>PeerConnection</code> ICE
            Agent</a> ICE state. </p>
          </dd>

          <dt>readonly attribute MediaStream[] localStreams</dt>

          <dd>
            <p>Returns a live array containing the local streams (those that
            were added with <code title="dom-PeerConnection-addStream">
                <a href="#dom-peerconnection-addstream">addStream()</a>
              </code>).</p>
          </dd>

          <dt>readonly attribute MediaStream[] remoteStreams</dt>

          <dd>
            <p>Returns a live array containing the streams that the remote
            streams. (those that were added by the remote side). </p>

            <p>This array is updated when <code>
                <a href="#event-mediastream-addstream">addstream</a>
              </code> and <code title="event-MediaStream-removestream">
                <a href="#event-mediastream-removestream">removestream</a>
              </code> events are fired.</p>
          </dd>

          <dt>void addStream (MediaStream stream, optional MediaConstraints
          constraints)</dt>

          <dd>
            <p>Attempts to starting sending the given stream to the remote
            peer. </p>

            <p>When the other peer starts sending a stream in this manner, an
            <code title="event-MediaStream-addstream">
                <a href="#event-mediastream-addstream">addstream</a>
              </code> event is fired at the <code>
                <a>PeerConnection</a>
              </code> object.</p>

            <p>When the <dfn id="dom-peerconnection-addstream">
                <code title="">addStream()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is already in the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object, then abort these steps.</p>
              </li>

              <li>
                <p>Add <var>stream</var> to the end of the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object.</p>
              </li>

              <li>
                <p>Return from the method.</p>
              </li>

              <li>
                <p>Parse the <var>constraints</var> provided by the
                application and apply them to the MediaStream, if possible.
                NOTE - need to deal with throwing an exception here. </p>
              </li>

              <li>
                <p>Have the <code>
                    <a>PeerConnection</a>
                  </code> add a media stream for <var>stream</var> the next
                time the user agent <span
                title="provide a stable state">provides a stable state</span>.
                Any other pending stream additions and removals MUST be
                processed at the same time.</p>
              </li>
            </ol>
          </dd>

          <dt>void removeStream (MediaStream stream)</dt>

          <dd>
            <p>Stops sending the given stream to the remote peer.</p>

            <p>When the other peer stops sending a stream in this manner, a
            <code title="event-MediaStream-removestream">
                <a href="#event-mediastream-removestream">removestream</a>
              </code> event is fired at the <code>
                <a>PeerConnection</a>
              </code> object.</p>

            <p>When the <dfn id="dom-peerconnection-removestream">
                <code title="">removeStream()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>If <var>stream</var> is not in the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object, then abort these steps.</p>
              </li>

              <li>
                <p>Remove <var>stream</var> from the <code>
                    <a>PeerConnection</a>
                  </code> object's <code
                    title="dom-PeerConnection-localStreams">
                    <a
                    href="#widl-PeerConnection-localStreams">localStreams</a>
                  </code> object.</p>
              </li>

              <li>
                <p>Return from the method.</p>
              </li>

              <li>
                <p>Have the <code>
                    <a>PeerConnection</a>
                  </code>remove the media stream for <var>stream</var> the
                next time the user agent <span
                title="provide a stable state">provides a stable state</span>.
                Any other pending stream additions and removals MUST be
                processed at the same time.</p>
              </li>

       
            </ol>
          </dd>

          <dt>void close ()</dt>

          <dd>
            <p>When the <dfn id="dom-peerconnection-close">
                <code title="">close()</code>
              </dfn> method is invoked, the user agent MUST run the following
            steps:</p>

            <ol>
              <li>
                <p>If the <code>
                    <a>PeerConnection</a>
                  </code> object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> is <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3), throw an <code>INVALID_STATE_ERR</code>
                exception.</p>
              </li>

              <li>
                <p>Destroy the <a
                href="#peerconnection-ice-agent"><code>PeerConnection</code>
                ICE Agent</a>, abruptly ending any active ICE processing and
                any active streaming, and releasing any relevant resources
                (e.g. TURN permissions).</p>
              </li>

              <li>
                <p>Set the object's <a
                href="#peerconnection-readiness-state"><code>PeerConnection</code>
                readiness state</a> to <code>
                    <a href="#widl-PeerConnection-CLOSED">CLOSED</a>
                  </code> (3).</p>
              </li>
            </ol>

            <p class="note">The <code>
                <a href="#widl-PeerConnection-localStreams">localStreams</a>
              </code> and <code title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> objects remain in the state they were in when the object
            was closed.</p>
          </dd>

          <dt>attribute Function? onrenegotationneeded</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-renegotiation-needed">renegotiationneeded</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

              <dt>attribute IceCandidateCallback? onnewicecandidate </dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-onnewicecandidate">onnewicecandidate</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. It is called any time there is a new ICE candiate
          can be added to the a previos offer or answer. </dd>

            

          <dt>attribute Function? onconnecting</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-connecting">connecting</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onopen</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-open">open</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onstatechange</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-open">open</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. It is called any time the readyState changes.
          </dd>

          <dt>attribute Function? onaddstream</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-addstream">addstream</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. Open Issue: It seems like this even handler needs
          to be fired when the first of two things happens - the remote side
          sends signaling indicating a media will be sent, or the side that
          sent an offer start receiving media in reply to that offer. </dd>

          <dt>attribute Function? onremovestream</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-removestream">removestream</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface.</dd>

          <dt>attribute Function? onicechange</dt>

          <dd>This event handler, of <span
          title="event handler event type">event handler event type</span>
          <code>
              <a href="#event-mediastream-icechange">icechange</a>
            </code>, MUST be supported by all objects implementing the <code>
              <a>PeerConnection</a>
            </code> interface. It is called any time the iceState
          changes.</dd>
        </dl>

        <div class="idl" title="PeerConnection implements EventTarget" />
      </section>
   </section>
 </section>
          
   <section>
      <h2 id="sec-iana">IANA Registrations</h2>

      
          <section>
      <h3 id="sec-constraints">Constraints</h3>

          <p> TOOD: Need to change the naming and declaration of these
          constraints to match the constraints draft once that is a bit further
          along. The names here now are likely not quite right but they serve as
          a place holder. </p> 
          
      <p> The following new constraints are defined that can be used with a
    PeerConnection object: <p>

      <dl>

             <dt> ReceiveVideo </dt>
        
        <dd> <p> This is a enum type constraint that can take the values "true"
        and "false". The default is a non mandatory "true" if the PeerConnection
        a video stream has been added an non mandatory "false" otherwise. </p>

          <p> In some cases, a PeerConenction may wish to receive video but it
          is not going to send any video. The PeerConenction needs to know if it
          should signal to the remote side if it wishes to receive video or
          not. This constraints allows an application to indicate it's
          preferences for receiving video when creating an offer. </p> </dd>

                  <dt> ReceiveAudio </dt>
        
        <dd> <p> This is a enum type constraint that can take the values "true"
        and "false". The default is a non mandatory "true". </p>

          <p> In some cases, a PeerConenction may wish to receive audio but it
          is not going to send any audio. The PeerConenction needs to know if it
          should signal to the remote side if it wishes to receive audi. This
          constraints allows an application to indicate it's preferences for
          receiving audio when creating an offer. </p> </dd>
        
        <dt> VoiceActivityDetection </dt>
        
        <dd> <p> This is a enum type constraint that can take the values "true"
        and "false". The default is a non mandatory "true". </p>

          <p> Many codecs and system are capable of detecting "silence" and
        changing there behavior in this case by doing things such as not
        transmitting any media. In many cases, such as when dealing with sounds
        other than spoken voice or emergency calling, it is desirable to be able
        to turn off this behavior. This constraints allows the application to
        provide information about if it wishes this type of processing enable or
        disabled.  </p> </dd>


        <dt> IceTransports </dt>

        <dd> <p> This is a enum type constraint that can take the values "none",
          "relay", and "all". The default is a non mandatory "all". </p>
          
        <dd> <p> This constraints indicates which candidates the ICE engine is
          restricted use. The value "none" means the ICE engine MUST not send or
          receive any packets at this point. The value "relay" indicates the ICE
          engine MUST only using media relay candidates such as candidates
          passing through a TURN server. This can be used to reduce leakage of
          IP addresses in certain use cases. The value of "all" indicates all
          values can be used. </p>
          
        </dd>
          
      </dl>

      <p> TODO items - need to register with IANA. </p>
      
    </section>

          </section>


<!--
      <section>
        <h3>SignalingCallback</h3>

        <dl class="idl"
            title="[Callback, NoInterfaceObject] interface SignalingCallback">
          <dt>void handleEvent (DOMString message, PeerConnection source)</dt>

          <dd>Def TBD</dd>
        </dl>
      </section>
-->
        
      <section>
        <h3>Examples</h3>

        <div>
          <p>When two peers decide they are going to set up a connection to
          each other, they both go through these steps. The STUN/TURN server
          configuration describes a server they can use to get things like
          their public IP address or to set up NAT traversal. They also have
          to send data for the signaling channel to each other using the same
          out-of-band mechanism they used to establish that they were going to
          communicate in the first place.</p>

          <p> TODO - need to change example to use async createOffer /
          createAnswer </p>
          
          <pre class="example sh_javascript">
var signalingChannel = createSignalingChannel();   
var pc = null;
var localStream = null; 

// Set up the call, get access to local media, and establish connectivity.
function start(isCaller) {
    // Create a PeerConnection and hook up the IceCallback
    pc = new webkitPeerConnection(
        "", function (candidate, moreToFollow) {
            signalingChannel.send(
                JSON.stringify({ "type": "candidate", "sdp": candidate }));
        });

    // Get the local stream and show it in the local video element.     
    navigator.webkitGetUserMedia(
        {"audio": true, "video": true}, 
        function (stream) {
            selfView.src = webkitURL.createObjectURL(stream);
            localStream = stream;
            if (isCaller)
                pc.addStream(stream);
            doSignal("offer"); 
        } )
    
    // Once remote stream arrives, show it in the remote video element.     
    pc.onaddstream = function(evt) {      
        remoteView.src = webkitURL.createObjectURL(evt.stream); 
    };
}

// The callee has accepted the call, attach their media and signal   
function accept() {
    pc.addStream(stream);
    doSignal("answer");
}

function doSignal(type) {
    switch (type) { 
    case "offer":
        msg = pc.createOffer(null); // TODO - switch to async version 
        break;
    case "pranswer":
        msg = pc.createAnswer(pc.remoteDescription, null);  // TODO - switch to async version
        setDirection(msg, "recvonly");
        break;
    case "answer":
        msg = pc.createAnswer(pc.remoteDescription, null);  // TODO - switch to async version
        setDirection(msg, "sendrecv");
        break;
    }   
    pc.setLocalDescription(type, msg);
    signalingChannel.send(
        JSON.stringify({ "type": type, "sdp": msg })
    );
}
         
signalingChannel.onmessage = function(evt) {
    var msg = JSON.parse(evt.data);
    switch (msg.type) {
    case "offer":
        // create the PeerConnection   
        start(false);
        // feed the received offer into the PeerConnection 
        pc.setRemoteDescription(msg.type, msg.sdp);
        // create provisional answer to allow ICE/DTLS to start
        doSignal("pranswer");       
        break;       
    case "pranswer":
    case "answer":     
        pc.setRemoteDescription(msg.type, msg.sdp);
        break;
    case "candidate":
        pc.addIceCandidate(msg);
        break;
    }
}
</pre>
        </div>
      </section>
  

    <section>
      <h2>The data stream</h2>

      <p class="note"> TODO - Merge the section from the master branch into
    here. </p>
    </section>

    <section>
      <h2>Garbage collection</h2>

      <p>A <code>Window</code> object <dfn
      id="concept-peerconnection-owner">has a strong reference</dfn> to any
      <code>
          <a>PeerConnection</a>
        </code> objects created from the constructor whose global object is
      that <code>Window</code> object.</p>

      <!-- we could be less strict here, e.g. dropping the reference when
  there’s no way for an event to be fired because there’s no event handlers
  registered and there’s no way for the remote peer to notice anything because
  no media is streaming; or e.g. dropping the reference when the object reaches
  the CLOSED state. But as dropping the reference in those cases is black-box
  indistinguishable from keeping the reference, I haven't bothered to work out
  the exact rules. If you do change this, see the /unloading document cleanup
  steps/. -->
    </section>

    <section>
      <h2>Event definitions</h2>

      <section>
        <h3>MediaStreamTrackEvent</h3>

        <p>The <code>
            <a href="#event-mediastreamtracklist-addtrack">addtrack</a>
          </code> and <code title="event-MediaStreamTracklist-removetrack">
            <a href="#event-mediastreamtracklist-removetrack">removetrack</a>
          </code> events use the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface.</p>

        <p><dfn title="Fire a track event">Firing a track event named
        <var>e</var></dfn> with a <code>
            <a>MediaStreamTrack</a>
          </code> <var>track</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamTrackEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamtrackevent-track">track</a>
          </code> attribute set to <var>track</var>, MUST be created and
        dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamTrackEventInit"
            title="[Constructor(DOMString type, optional MediaStreamTrackEventInit eventInitDict)]     interface MediaStreamTrackEvent : Event">
          <dt>readonly attribute MediaStreamTrack? track</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamtrackevent-track">
                <code>track</code>
              </dfn> attribute represents the <code>
                <a>MediaStreamTrack</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl"
            title="dictionary MediaStreamTrackEventInit : EventInit">
          <dt>MediaStreamTrack? track</dt>

          <dd>
            <p>-</p>
          </dd>
        </dl>
      </section>

      <section>
        <h3>MediaStreamEvent</h3>

        <p>The <code>
            <a href="#event-mediastream-addstream">addstream</a>
          </code> and <code title="event-MediaStream-removestream">
            <a href="#event-mediastream-removestream">removestream</a>
          </code> events use the <code>
            <a>MediaStreamEvent</a>
          </code> interface.</p>

        <p><dfn id="fire-a-stream-event" title="fire a stream event">Firing a
        stream event named <var>e</var></dfn> with a <code>
            <a>MediaStream</a>
          </code> <var>stream</var> means that an event with the name
        <var>e</var>, which does not bubble (except where otherwise stated)
        and is not cancelable (except where otherwise stated), and which uses
        the <code>
            <a>MediaStreamEvent</a>
          </code> interface with the <code>
            <a href="#dom-mediastreamevent-stream">stream</a>
          </code> attribute set to <var title="">stream</var>, MUST be created
        and dispatched at the given target.</p>

        <dl class="idl" data-merge="MediaStreamEventInit"
            title="[Constructor(DOMString type, optional MediaStreamEventInit eventInitDict)] interface MediaStreamEvent : Event">
          <dt>readonly attribute MediaStream? stream</dt>

          <dd>
            <p>The <dfn id="dom-mediastreamevent-stream">
                <code>stream</code>
              </dfn> attribute represents the <code>
                <a>MediaStream</a>
              </code> object associated with the event.</p>
          </dd>
        </dl>

        <dl class="idl" title="dictionary MediaStreamEventInit : EventInit">
          <dt>MediaStream? stream</dt>

          <dd>
            <p>-</p>
          </dd>
        </dl>
      </section>
    </section>

    <section class="informative">
      <h2>Event summary</h2>

      <p>The following event fires on <code>
          <a>MediaStream</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStream</a>
              </code> <a>finished</a> as a result of all tracks in the <code>
                <a>MediaStream</a>
              </code> <a title="ended">ending</a>.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrack</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtrack-muted">
                <code>muted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is temporarily unable to provide
            data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-unmuted">
                <code>unmuted</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source is live again after having been
            temporarily unable to provide data.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtrack-ended">
                <code>ended</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The <code>
                <a>MediaStreamTrack</a>
              </code> object's source will no longer provide any data, either
            because the user revoked the permissions, or because the source
            device has been ejected, or because the remote peer stopped
            sending data, or because the <code>
                <a href="#dom-mediastream-stop">stop()</a>
              </code> method was invoked.</td>
          </tr>
        </tbody>
      </table>

      <p>The following event fires on <code>
          <a>MediaStreamTrackList</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-addtrack">
                <code>addtrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A new <code>
                <a>MediaStreamTrack</a>
              </code> has been added to this list.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastreamtracklist-removetrack">
                <code>removetrack</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamTrackEvent</a>
              </code>
            </td>

            <td>A <code>
                <a>MediaStreamTrack</a>
              </code> has been removed from this list.</td>
          </tr>
        </tbody>
      </table>

      <p>The following events fire on <code>
          <a>PeerConnection</a>
        </code> objects:</p>

      <table>
        <tr>
          <th>Event name</th>

          <th>Interface</th>

          <th>Fired when...</th>
        </tr>

        <tbody>
          <tr>
            <td>
              <dfn id="event-mediastream-connecting">
                <code>connecting</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The ICE Agent has begun negotiating with the peer. This can
            happen multiple times during the lifetime of the <code>
                <a>PeerConnection</a>
              </code> object.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-open">
                <code>open</code>
              </dfn>
            </td>

            <td>
              <code>Event</code>
            </td>

            <td>The ICE Agent has finished negotiating with the peer.</td>
          </tr>

          <!--
        <tr>
          <td><dfn title="event-MediaStream-error"><code>error</code></dfn></td>
          <td><code>Event</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="event-MediaStream-close"><code>close</code></dfn></td>
          <td><code>Event</code></td>
          <td>The <code title="dom-PeerConnection-close">close()</code> method was
            called. </td>
          </tr>
          -->

          <tr>
            <td>
              <dfn id="event-mediastream-message">
                <code>message</code>
              </dfn>
            </td>

            <td>
              <code>MessageEvent</code>
            </td>

            <td>A <!--<a href="#data-udp-media-stream">-->data UDP media
            stream<!--</a>--> message was received.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-addstream">
                <code>addstream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A new stream has been added to the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>

          <tr>
            <td>
              <dfn id="event-mediastream-removestream">
                <code>removestream</code>
              </dfn>
            </td>

            <td>
              <code>
                <a>MediaStreamEvent</a>
              </code>
            </td>

            <td>A stream has been removed from the <code
                title="dom-PeerConnection-remoteStreams">
                <a href="#widl-PeerConnection-remoteStreams">remoteStreams</a>
              </code> array.</td>
          </tr>


          <tr>
            <td>
              <dfn id="event-renegotiation">
              <code>renegotiationneeded</code>
              </dfn>
            </td>
            
            <td>
              <code>
              <a>MediaRenegotiationNeededEvent</a>
              </code>
            </td>

            <td>The browser wishes to inform the application that session
          negotiation needs to be redone at some point in the near future. Open
          Issue: should this be moved to "Negotiation Needed" instead of
          "RE-Negotiation Needed"?
          </td>

          </tr>


          
        </tbody>
      </table>
    </section>

 

    <section>
      <h2>Change Log</h2>

      <p> This section will be removed before publication. </p>

      <h3> To Do Items </h3>

     <h3> Changes since TODO - put date </h3>

      <ol>
        <li> TODO </li>
      </ol>

      <h3> Changes since 12 January 2012</h3>

      <ol>
        <li> Clarified what relation of Stream, Track, and Channel. </li>
      </ol>

      <h3> Changes since 17 October 2011</h3>

      <ol>
        <li>Tweak the introduction text and add a reference to the IETF RTCWEB
        group.</li>

        <li>Changed the first argument to getUserMedia to be an object.</li>

        <li>Added a MediaStreamHints object as a second argument to
        PeerConnection.addStream.</li>

        <li>Added AudioMediaStreamTrack class and DTMF interface.</li>
      </ol>

      <h3> Changes since 23 August 2011</h3>

      <ol>
        <li> Separated the SDP and ICE Agent into separate agents and added
        explicit state attributes for each. </li>

        <li> Removed the send method from PeerConenction and associated
        callback function. </li>

        <li>Modified MediaStream() constructor to take a list of
        MediaStreamTrack objects instead of a MediaStream. Removed text about
        MediaStream parent and child relationship.</li>

        <li>Added abstract.</li>

        <li>Moved a few paragraphs from the MediaStreamTrack.label section to
        the MediaStream.label section (where they belong).</li>

        <li>Split MediaStream.tracks into MediaStream.audioTracks and
        MediaStream.videoTracks.</li>

        <li>Removed a sentence that implied that track access is limited to
        LocalMediaStream.</li>

        <li>Updated a few getUserMedia()-examples to use
        MediaStreamOptions.</li>

        <li>Replaced calls to URL.getObjectURL() with URL.createObjectURL() in
        example code.</li>

        <li>Fixed some broken getUserMedia() links.</li>

        <li>Introduced state handling on MediaStreamTrack (removed state
        handling from MediaStream).</li>

        <li>Reintroduced onended on MediaStream to simplify checking if all
        tracks are ended.</li>

        <li>Aligned the MediaStreamTrack ended event dispatching behavior with
        that of MediaStream.</li>

        <li>Updated the LocalMediaStream.stop() algorithm to implicitly use
        the end track algorithm.</li>

        <li>Replaced an occurrence the term finished track with ended track
        (to align with rest of spec).</li>

        <li>Moved (and extended) the explanation about track references and
        media sources from LocalMediaStream to MediaStreamTrack.</li>

        <li>Removed section "Obtaining local multimedia content".</li>

        <li>Updated getUserMedia() calls in examples (changes in Media Capture
        TF spec).</li>

        <li>Introduced MediaStreamTrackList interface with support for adding
        and removing tracks.</li>

        <li>Updated the algorithm that is run when PeerConnection receives a
        stream (create new stream when negotiated instead of when data
        arrives).</li>
      </ol>
    </section>

    <section class="appendix">
      <h2>Acknowledgements</h2>

      <p>The editors wish to thank the Working Group chairs, Harald Alvestrand
      and Stefan Håkansson, for their support.</p>
    </section>
  </body>
</html>
