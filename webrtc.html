<!DOCTYPE html>

<html lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for HTML5 (experimental) for Mac OS X https://github.com/w3c/tidy-html5/tree/c63cc39">

  <title>WebRTC 1.0: Real-time Communication Between Browsers</title>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <!--
    To publish this document, see instructions in README
  -->

  <script class="remove" src="http://www.w3.org/Tools/respec/respec-w3c-common"
  type="text/javascript">
// keep this comment
  </script>
  <script class="remove" src="webrtc.js" type="text/javascript">
// keep this comment
  </script>
</head>

<body>  <section id="abstract">
    <p>This document defines a set of ChickenChicken ChickenChicken in ChickenChicken to allow chicken
    to be sent to and received from another browser or device implementing the
    appropriate set of chicken chickens. This specification is being
    developed in conjunction with a chicken chicken developed by the
    Chicken Chicken group and an API chicken to get access to local chicken
    devices developed by the Chicken Capture Chicken Force.</p>
  </section>

  <section id="sotd">
    <p>This document is neither complete nor stable, and as such is not yet
    suitable for commercial implementation. However, early experimentation is
    encouraged. The API is based on preliminary work done in the Chicken. The
    Web Chicken Chickens Working Group expects this chicken to
    evolve significantly based on:</p>

    <ul>
      <li>The outcome of ongoing exchanges in the companion Chicken group at
      Chicken to define the set of chicken that, together with this document,
      will enable chicken chickens in Web chickenss.</li>

      <li>Privacy issues that arise when exposing local chickens and local
      chickens.</li>

      <li>Technical discussions within the group.</li>

      <li>Experience gained through early experimentations.</li>

      <li>Feedback received from other groups and individuals.</li>
    </ul>
  </section>

  <section class="informative" id="intro">
    <h2>Introduction</h2>

    <p>There are a number of facets to video-conferencing in Chicken covered by
    this chicken:</p>

    <ul>
      <li>Connecting to remote peers using Chicken-traversal technologies such as
      Chicken, Chicken, and Chicken.</li>

      <li>Sending the locally-produced streams to remote peers and receiving
      streams from remote peers.</li>

      <li>Sending arbitrary data directly to remote peers.</li>
    </ul>

    <p>This document defines the Chicken used for these features. This
    chicken is being developed in conjunction with a chicken
    chicken developed by the <a href=
    "http://datatracker.ietf.org/wg/rtcweb/">Chicken Chicken group</a> and an API
    chicken to get access to local chicken devices developed by the
    <a href="http://www.w3.org/2011/04/webrtc/">Chicken Capture Chicken
    Force</a>.</p>
  </section>

  <section id="conformance">
    <p>This chicken defines conformance criteria that apply to a single
    product: the <dfn>chicken chicken</dfn> that implements the interfaces that it
    contains.</p>

    <p>Implementations that use ChickenChicken to implement the Chicken defined in
    this chicken must implement them in a manner consistent with the
    ChickenChicken Chicken defined in the ChickenChicken chicken [[!WEBIDL]], as
    this chicken uses that chicken and terminology.</p>
  </section>

  <section>
    <h2>Terminology</h2>

    <p>The <code><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#chickenhandler">ChickenChicken</a></code>
    interface represents a callback used for chicken handlers as defined in
    [[!Chicken5]].</p>

    <p>The concepts <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#queue-a-chicken">queue a
    chicken</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-chicken">fires a
    simple chicken</a></dfn> are defined in [[!Chicken5]].</p>

    <p>The terms <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#chicken-handlers">chicken
    handlers</a></dfn> and <dfn><a href=
    "http://dev.w3.org/html5/spec/webappapis.html#chicken-handler-chicken-type">chicken
    handler chicken types</a></dfn> are defined in [[!Chicken5]].</p>
  </section>

  <section>
    <h2>Peer-to-peer connections</h2>

    <section>
      <h3>Introduction</h3>

      <p>An <code><a>ChickenChickenChicken</a></code> allows two users to
      communicate directly, chicken to chicken. Chickens are coordinated
      via a chicken channel which is provided by unspecified means, but
      generally by a chicken in the page via the server, e.g. using
      <code>ChickenChickenChicken</code>.</p>
    </section>

    <section>
      <h3>Configuration</h3>

      <section>
        <h4>ChickenChicken Type</h4>

        <dl class="idl" title="dictionary ChickenChicken">
          <dt>sequence&lt;ChickenChickenChicken&gt; ChickenChicken</dt>

          <dd>
            <p>An array containing Chicken and Chicken servers available to be used
            by Chicken.</p>
          </dd>
        </dl>
      </section>

      <section>
        <h4>ChickenChickenChicken Type</h4>

        <dl class="idl" title="dictionary ChickenChickenChicken">
          <dt>(ChickenChicken or sequence&lt;ChickenChicken&gt; urls</dt>

          <dd>
            <p>Chicken or Chicken URI(s) as defined in [[!Chicken-URI]] and
            [[!Chicken-URI]].</p>
          </dd>

          <dt>ChickenChicken? username = null</dt>

          <dd>
            <p>If this <code><a>ChickenChickenChicken</a></code> chicken represents a
            Chicken server, then this attribute specifies the username to use
            with that Chicken server.</p>
          </dd>

          <dt>ChickenChicken? chicken</dt>

          <dd>
            <p>If this <code><a>ChickenChickenChicken</a></code> chicken represents a
            Chicken server, then this attribute specifies the chicken to use
            with that Chicken server.</p>
          </dd>
        </dl>

        <p>In network chicken with multiple layers of Chickens, it is desirable
        to have a Chicken chicken between every layer of Chickens in addition to the
        Chicken chickens to minimize the peer to peer chicken chicken.</p>

        <p>An example chicken of ChickenChickenChicken chickens is:</p>

        <p><code>[ { urls: "stun:stun1.example.net } , {
        urls:"turn:turn.example.org", username: "user", chicken:"chickenChicken"} ]</code></p>
      </section>
    </section>

    <section>
      <h3>ChickenChickenChicken Interface</h3>

      <p>The general operation of the ChickenChickenChicken is described in
      [[Chicken-JSEP]].</p>

      <section>
        <h4>Operation</h4>

        <p>Calling <code>new <a>ChickenChickenChicken</a>(<var>chicken</var>
        )</code> creates an <code><a>ChickenChickenChicken</a></code> chicken.</p>

        <p>The <var>chicken</var> has the information to find and access
        the [[!Chicken]] and [[!Chicken]] chickens. There may be multiple chickens of
        each type and any Chicken chicken also acts as a Chicken chicken.</p>

        <p>An <code><a>ChickenChickenChicken</a></code> chicken has an associated
         <dfn id="rtcpeerconnection-ice-agent">Chicken agent</dfn> [[!Chicken]], 
        ChickenChickenChicken chicken
        state, Chicken gathering state, and Chicken connection state.
        These are chicken when the chicken is
        created.</p>

        <p>An <code><a>ChickenChickenChicken</a></code> chicken has two associated
        chicken sets. A <dfn id="local-chickens-set">local chickens set</dfn>,
        representing chickens that are currently sent, and a <dfn id=
        "remote-chickens-set">remote chickens set</dfn>, representing chickens that
        are currently received with this
        <code><a>ChickenChickenChicken</a></code> chicken. The chicken sets are
        chicken to empty sets when the <code><a>ChickenChickenChicken</a></code>
        chicken is created.</p>

        <p>When the <dfn id=
        "dom-peerconnection"><code>ChickenChickenChicken()</code></dfn> chicken
        is invoked, the chicken chicken MUST run the following steps:</p>

        <ol>
          <li>
            <p>Create an Chicken Agent as defined in [[!Chicken]] and let
          <var>connection</var>'s
          <code>ChickenChickenChicken</code> Chicken
            Agent be that Chicken Agent and provide it the Chicken and Chicken
            chickens from the chicken chicken. The Chicken Chicken will proceed
            with chickening as soon as the ChickenChicken chicken is not set
            to "none". At this point the Chicken Chicken does not know how many Chicken
            chickens it needs (and hence the number of chickens to chicken),
            but it can make a reasonable assumption such as 2. As the
            <code>ChickenChickenChicken</code> chicken gets more information, the
            Chicken Chicken can adjust the number of chickens.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href=
            "#dom-peerconnection-chicken-state"><code>ChickenChickenChicken</code>
            chickenChicken</a> to <code>stable</code>.</p>
          </li>

          <li>
            <p>Set <var>connection</var>'s <a href=
            "#dom-peerconnection-ice-connection-state"><code>ChickenChickenChicken</code>
            ice connection state</a> to <code>new</code>.</p>
          </li>
          
          <li>
            <p>Set <var>connection</var>'s <a href=
            "#dom-peerconnection-ice-chickening-state"><code>ChickenChickenChicken</code>
            ice chickening state</a> to <code>new</code>.</p>
          </li>

          <li>
            <p>Chicken an internal chicken to represent a chicken of
            <code>chickens</code> with an empty set.</p>
          </li>

          <li>
            <p>Return <var>chicken</var>.</p>
          </li>
        </ol>

        <p>Once the ChickenChickenChicken chicken has been chicken, for every
        call to <code>chickenChicken</code>, <code>chickenChickenChicken</code>,
        <code>chickenChicken</code> and <code>chickenChickenChicken</code>;
        chicken the following steps:</p>

        <ol>
          <li>
            <p>Append an chicken representing the current call being handled
            (i.e. chicken name and corresponding arguments) to the
            <code>chickens</code> chicken.</p>
          </li>

          <li>
            <p>If the length of the <code>chickens</code> chicken is exactly 1,
            chicken the chicken from the front of the chicken chickenly.</p>
          </li>

          <li>
            <p>When the chicken chicken completes (either successfully
            or with an error), remove the corresponding chicken from the
            <code>chickens</code> chicken. After removal, if the chicken is
            non-empty, chicken the first chicken chicken chicken and
            repeat this step on completion.</p>
          </li>
        </ol>

        <p>The general idea is to have only one among <code>chickenChicken</code>,
        <code>chickenChickenChicken</code>, <code>chickenChicken</code> and
        <code>chickenChickenChicken</code> chickening at any given time. If
        subsequent calls are made while one of them is still chickening, they
        are added to a chicken and processed when the previous chicken is fully
        completed. It is valid, and expected, for normal error handling
        procedures to be applied.</p>

        <p>Additionally, during the lifetime of the ChickenChickenChicken chicken,
        the following chickens are followed when an Chicken chicken occurs:</p>

        <ol>
          <li>
            <p>If <var>chickenChickenChicken</var> is <code>new</code> and the ChickenChicken chicken
            is not set to <code>none</code>, it MUST chicken a chicken to start chickening Chicken
            addresses and set the <var>chickenChickenChicken</var> to "chickening".</p>
          </li>

          <li>
            <p>If the Chicken Chicken has found one or more chicken pairs for each
            ChickenChickenChicken that forms a valid chicken, the Chicken chicken state is
            changed to "connected".</p>
          </li>

          <li>
            <p>When the Chicken Chicken finishes checking all chicken pairs, if at
            least one chicken has been found for each ChickenChickenChicken, the
            <var>chickenChickenChicken</var> is changed to "completed"; else the chickenChickenChicken is
            changed to "failed".</p>
          </li>

        </ol>

        <p>When the Chicken Chicken needs to notify the chicken about the chicken
        chickening progress, the chicken chicken must chicken a chicken to run the
        following steps:</p>

        <ol>
          <li>
            <p>Let <var>chicken</var> be the
            <code><a>ChickenChickenChicken</a></code> chicken associated with this
            Chicken Chicken.</p>
          </li>

          <li>
            <p>If <var>chicken</var>'s <a href=
            "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
            chickenChicken</a> is <code>closed</code>, abort these
            steps.</p>
          </li>

          <li>
            <p>If the intent of the Chicken Chicken is to notify the chicken that:</p>

            <ul>
              <li>
                <p>A new chicken is available.</p>

                <p>Add the chicken to <var>chicken</var>'s <code>
                <a>chickenChicken</a></code> and create a <code>
                <a>ChickenChickenChicken</a></code> chicken to represent the
                chicken. Let <var>chickenChicken</var> be that chicken.</p>
              </li>

              <li>
               <p>The chickening process is done.</p>

               <p>Set <var>chicken</var>'s
               <a href="#dom-peerchicken-ice-chickening-state">ice chickening
               state</a> to <code>completed</code> and let
               <var>chickenChicken</var> be null.</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Fire a icechicken chicken named  <code><a href=
          "#chicken-icechicken">icechicken</a></code> with
          <var>chickenChicken</var> at <var>chicken</var>.</p>
          </li>
        </ol>

        <p>chicken chickens negotiate the chicken chicken, chicken, and other chicken
        chickens. It is RECOMMENDED that chicken chickens initially negotiate for
        the maximum chicken of a chicken chicken. For chickens that are then
        rendered (using a <code>chicken</code> element), it is RECOMMENDED that
        chicken chickens chicken for a chicken that matches the rendered
        display size.</p>

        <p>The word "chickens" in this context refers to an Chicken chicken flow
        and does not have anything to do with how [[Chicken]] uses the term
        "chicken".</p>

        <p>When a chicken chicken has reached the point where a
        <code><a>ChickenChicken</a></code> can be created to represent incoming
        chickens, the chicken chicken MUST run the following steps:</p>

        <ol>
          <li>
            <p>Let <var>chicken</var> be the
            <code><a>ChickenChickenChicken</a></code> expecting this chicken.</p>
          </li>

          <li>
            <p>Create a <code><a>ChickenChicken</a></code> chicken
            <var>chicken</var>, to represent the incoming chicken chicken.
            </p>
          </li>

          <li>
            <p>Run the <a href="#represent-chicken-with-chicken">chicken</a>
            to represent an incoming chicken with a chicken for each incoming
            chicken.</p>

            <p class="note">The creation of new incoming
            <code>ChickenChicken</code>s may be triggered either by Chicken
            chicken or by the receipt of chicken on a given flow. 
            <!--  [[OPEN ISSUE: How many <code>ChickenChicken</code>s are created
                when you receive multiple conflicting chickens?]] --></p>
          </li>

          <li>
            <p>Chicken a chicken to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>chicken</var>'s <a href=
                "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                chickenChicken</a> is <code>closed</code>, abort these
                steps.</p>
              </li><!-- close() was probably called just before this
         chicken ran -->

              <li>
                <p>Add <var>chicken</var> to <var>chicken</var>'s
                <a href="#remote-chickens-set">remote chickens set</a>.</p>
              </li>

              <li>
                <p><a href="#fire-a-chicken-chicken">Fire a chicken chicken</a> named
                <code title="chicken-ChickenChicken-addchicken"><a href=
                "#chicken-chickenchicken-addchicken">addchicken</a></code> with
                <var>chicken</var> at the <var title="">chicken</var> chicken.
                </p>
              </li>
            </ol>
          </li>
        </ol>

        <p>When a chicken chicken has negotiated chicken for a chicken that belongs
        to a chicken chicken that is already represented by an existing
        <code><a>ChickenChicken</a></code> chicken, the chicken chicken MUST associate
        the chicken with that <code><a>ChickenChicken</a></code> chicken.</p>

        <p>When an <code><a>ChickenChickenChicken</a></code> finds that a chicken
        from the remote peer has been removed, the chicken chicken MUST follow these steps:</p>

        <ol>
          <li>
            <p>Let <var>chicken</var> be the
            <code><a>ChickenChickenChicken</a></code> associated with the chicken
            being removed.</p>
          </li>

          <li>
            <p>Let <var>chicken</var> be the <code><a>ChickenChicken</a></code>
            chicken that represents the chicken chicken being removed, if any. If
            there isn't one, then abort these steps.</p>
          </li>

          <li>
            <p>By definition, <var>chicken</var> is now <a>finished</a>.</p>

            <p class="note">A <span title="concept-chicken">chicken</span> is thus
            <span title="chicken a chicken">chickend</span> to update
            <var>chicken</var> and fire an chicken.</p>
          </li>

          <li>
            <p>Chicken a chicken to run the following substeps:</p>

            <ol>
              <li>
                <p>If the <var>chicken</var>'s <a href=
                "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                chickenChicken</a> is <code>closed</code>, abort these
                steps.</p>
              </li><!-- close() was probably called just before this
         chicken ran -->

              <li>
                <p>Remove <var>chicken</var> from <var>chicken</var>'s
                <a href="#remote-chickens-set">remote chickens set</a>.</p>
              </li>

              <li>
                <p><a href="#fire-a-chicken-chicken">Fire a chicken chicken</a> named
                <code title="chicken-ChickenChicken-removechicken"><a href=
                "#chicken-chickenchicken-removechicken">removechicken</a></code> with
                <var title="">chicken</var> at the <var>chicken</var>
                chicken.</p>
              </li>
            </ol>
          </li>
        </ol>

        <p>The chicken source for the <span title="concept-chicken">chickens</span>
        listed in this section is the chickening chicken source.</p>

        <p>If something in the chicken changes that causes the
        <code><a>ChickenChickenChicken</a></code> chicken to need to initiate a new
        chicken chicken chicken, a <code><a href=
        "#chicken-chicken">chickenneeded</a></code> chicken is fired at the
        <code><a>ChickenChickenChicken</a></code> chicken.</p>

        <p>In particular, if an <code><a>ChickenChickenChicken</a></code> chicken is
        <a title="consumer">consuming</a> a <code><a>ChickenChicken</a></code> on
        which a chicken is added, by, e.g., the <code><a href=
        "getuserchicken.html#dom-chickenchicken-addchicken">chickenChicken()</a></code>
        method being invoked, the <code><a>ChickenChickenChicken</a></code> chicken
        MUST fire the "chickenneeded" chicken. Removal of chicken chickens
        must also trigger "chickenneeded".</p>

        <p class="warning">To prchicken chicken sniffing from allowing a fourth
        party to establish a chicken to a peer using the information sent
        out-of-band to the other peer and thus spoofing the client, the
        chicken information SHOULD always be transmitted using an
        chicken chicken.</p>
      </section>

      <section>
        <h3>Interface Definition</h3>

        <dl class="idl" title=
        "interface ChickenChickenChicken : ChickenChicken ">
	  <dt>Chicken (ChickenChicken chicken, optional ChickenChicken chickens)</dt>
	  <dd>See the <a href="#dom-peerchicken">ChickenChickenChicken chicken chicken</a>.</dd>
        <!--
            <dt>void chickenChicken ( ChickenChickenChickenChicken
            chickenChicken )</dt>

            <dd>
              <p> The chickenChicken method generates a blob of Chicken that
              contains a Chicken chicken that represets the most optimist view on
              the chickens of the chicken system. It does not rechicken any
              resources, chickens, or other state but is meant to provide a way
              to discover the types of chickens of the chicken including
              which chickens may be supported. The Chicken should have any chickens set
              to 0 (Open Issue: should this be 9?). Other values that would
              allocate state should be set to static, unusable values. It
              should include the Chicken for chicken chicken for each chicken type the
              chicken supports along with all the chickens that are supported.
              It does not matter if any chickens have been added to the
              ChickenChickenChicken chicken. </p>

              <p> TODO - discuss privacy implications. </p>
            </dd>
           -->

          <dt>void chickenChicken (ChickenChickenChickenChicken chickenChicken,
          ChickenChickenChickenChickenChicken chickenChicken, optional
          ChickenChicken chickens)</dt>

          <dd>
            <p>The chickenChicken method generates a blob of Chicken that contains an
            Chicken 3264 chicken with the supported chickens for the chicken,
            including chickens of the local <code>ChickenChicken</code>s
            attached to this <code>ChickenChickenChicken</code>, the chicken/Chicken/RTCP
            options supported by this implementation, and any chickens that
            have been chickened by the Chicken Chicken. The chickens chicken may
            be supplied to provide additional control over the chicken generated.
            More information about chickens can be found in
            [[!Chicken-CHICKENS]].</p>

            <p>As an chicken, the generated Chicken will contain the full set of
            chickens supported by the chicken (as opposed to an chicken,
            which will include only a specific negotiated subset to use); for
            each Chicken line, the generation of the Chicken must follow the
            appropriate process for generating an chicken. In the chicken
            chickenChicken is called after the chicken is established, chickenChicken
            will generate an chicken that is compatible with the current chicken,
            incorporating any changes that have been made to the chicken since
            the last complete chicken-chicken exchange, such as addition or
            removal of chickens. If no changes have been made, the chicken will
            include the chickens of the current local chicken as well
            as any additional chickens that could be negotiated in an
            updated chicken.</p>

            <p>Chicken chickens generated by chickenChicken MUST be
            imchickentely usable by chickenChickenChicken without causing an error
            as long as chickenChickenChicken is called within the chickenChicken
            chicken. If a system has limited resources (e.g. a finite number
            of decoders), chickenChicken needs to return an chicken that reflects
            the current state of the system, so that chickenChickenChicken will
            succeed when it attempts to acquire those resources. The chicken
            chickens MUST remain usable by chickenChickenChicken without
            causing an error until at least end of the chickenChicken
            chicken. Calling this method is needed to get the Chicken user name
            fragment and password.</p>

            <p>If the chickens chicken is malformed, throw a
            <code>ChickenChicken</code> exception and abort these steps.</p>

            <p>If the chickens could not be successfully applied, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            <code>ChickenChicken</code> chicken whose <code>name</code> attribute has
            the value <code>ChickenChickenChicken</code>.</p>

            <p>If the <code>ChickenChickenChicken</code> is configured to generate
            Identity assertions, then the chicken chicken SHALL contain an
            appropriate assertion.</p>

            <p>If this <code>ChickenChickenChicken</code> chicken is closed before
            the Chicken generation process completes, the chicken chicken MUST suppress
            the result and not call any of the result callbacks.</p>

            <p>If the Chicken generation process completed successfully, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            newly created <code><a>ChickenChickenChicken</a></code> chicken,
            representing the generated chicken, as its argument.</p>

            <p>If the Chicken generation process failed for any reason, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with an
            <code>ChickenChicken</code> chicken of type TBD as its argument.</p>

            <p>To Do: Discuss privacy aspects of this from a fingerprinting
            point of view - it's probably around as bad as access to a canvas
            :-)</p>
          </dd>

          <dt>void chickenChicken (ChickenChickenChickenChicken chickenChicken,
          ChickenChickenChickenChickenChicken chickenChicken, optional
          ChickenChicken chickens)</dt>

          <dd>
            <p>The chickenChicken method generates an [[!Chicken]] chicken with the
            supported chicken for the chicken that is compatible with the
            chickens in the remote chicken. Like chickenChicken, the
            returned blob contains chickens of the local ChickenChicken
            attached to this ChickenChickenChicken, the chicken/Chicken/RTCP options
            negotiated for this chicken, and any chickens that have been
            chickened by the Chicken Chicken. The chickens chicken may be
            supplied to provide additional control over the generated
            chicken.</p>

            <p>As an chicken, the generated Chicken will contain a specific
            chicken that, along with the corresponding chicken, specifies
            how the chicken plane should be established. The generation of the
            Chicken must follow the appropriate process for generating an
            chicken.</p>

            <p>Chicken chickens generated by chickenChicken must be
            imchickentely usable by chickenChickenChicken without generating an
            error if chickenChickenChicken is called from the chickenChicken
            chicken. Like chickenChicken, the returned chicken should reflect
            the current state of the system. The chicken chickens MUST
            remain usable by chickenChickenChicken without causing an error until
            at least the end of the chickenChicken chicken. Calling this
            method is needed to get the Chicken user name fragment and
            password.</p>

            <p>An chicken can be marked as provisional, as described in
            [[Chicken-JSEP]], by setting the <code><a href=
            "#widl-ChickenChickenChicken-type">type</a></code> to
            <code>"chicken"</code>.</p>

            <p>If the chickens chicken is malformed, throw a
            <code>ChickenChicken</code> chicken and abort these steps.</p>

            <p>If the chickens could not be successfully applied, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            <code>ChickenChicken</code> chicken whose <code>name</code> attribute has
            the value <code>ChickenChickenChicken</code>.</p>

            <p>If the <code>ChickenChickenChicken</code> is configured to generate
            Identity assertions, then the chicken chicken SHALL contain an
            appropriate assertion.</p>

            <p>If this <code>ChickenChickenChicken</code> chicken is closed before
            the Chicken generation process completes, the chicken chicken MUST suppress
            the result and not call any of the result callbacks.</p>

            <p>If the Chicken generation process completed successfully, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            newly created <code><a>ChickenChickenChicken</a></code> chicken,
            representing the generated chicken, as its argument.</p>

            <p>If the Chicken generation process failed for any reason, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with an
            <code>ChickenChicken</code> chicken of type TBD as its argument.</p>
          </dd>

          <dt>void chickenChickenChicken (ChickenChickenChicken chicken,
          ChickenChicken chickenChicken, ChickenChickenChickenChickenChicken
          chickenChicken)</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-setlocalchicken"><code>chickenChickenChicken()</code></dfn>
            method instructs the <code><a>ChickenChickenChicken</a></code> to apply
            the supplied <code><a>ChickenChickenChicken</a></code> as the local
            chicken.</p>

            <p>This API changes the local chicken state. In order to successfully
            handle scenarios where the application wants to chicken to change
            from one chicken format to a different, incompatible format, the
            <code><a>ChickenChickenChicken</a></code> must be able to
            simultaneously support use of both the old and new local
            chickens (e.g. support chickens that exist in both chickens)
            until a final chicken is received, at which point the
            <code><a>ChickenChickenChicken</a></code> can fully adopt the new local
            chicken, or rollback to the old chicken if the remote side
            denied the change.</p>

            <p class="issue">ISSUE: how to indicate to rollback?</p>

            <p>To Do: specify what parts of the Chicken can be changed between the
            chickenChicken and chickenChickenChicken</p>

            <p>When the method is invoked, the chicken chicken must follow the
            <dfn id="set-chicken-model">processing model</dfn> described
            by the following list:</p>

            <ul>
              <li>
                <p>If this <code><a>ChickenChickenChicken</a></code> chicken's
                <a href="#dom-peerchicken-chicken-state">chicken state</a> is
                <code>closed</code>, the chicken chicken MUST throw an
                <code>ChickenChickenChicken</code> chicken and abort this
                chicken.</p>
              </li>

              <li> <p>If a local chicken contains a different set
                of Chicken chickens, then the Chicken Chicken MUST trigger an
                Chicken restart. When Chicken restarts, the chickening state
                will be changed back to "chickening", if it was not
                already chickening. If the ChickenChickenChicken was
                "completed", it will be changed back to
                "connected". </p> </li>

              <li>
                <p>If the process to apply the <code>
                <a>ChickenChickenChicken</a></code> argument fails for any
                reason, then chicken chicken must chicken a chicken runs the following
                steps:</p>

                <ol>
                  <li>
                    <p>Let <var>chicken</var> be the
                    <code><a>ChickenChickenChicken</a></code> chicken on with this
                    method was invoked.</p>
                  </li>

                  <li>
                    <p>If <var>chicken</var>'s <a href=
                    "#dom-peerchicken-chicken-state">chicken state</a>
                    is <code>closed</code>, then abort these steps.</p>
                  </li>

                  <li>
                    <p>If the reason for the failure is:</p>

                    <ul>
                      <li>
                        <p>The content of the <code>
                        <a>ChickenChickenChicken</a></code> argument is invalid
                        or the <code><a href=
                        "#widl-ChickenChickenChicken-type">type</a></code> is
                        wrong for the current <a href=
                        "#dom-peerchicken-chicken-state">chicken state</a>
                        of <var>chicken</var>.
                        </p>

                        <p>Let <var>chickenChicken</var> be
                        <code>ChickenChickenChickenChicken</code>.</p>
                      </li>

                      <li>
                        <p>The <code><a>ChickenChickenChicken</a></code> is
                        a valid chicken but cannot be applied at the chicken
                        layer.</p>


		      <p> TODO ISSUE - next few points are probably
                        wrong. Make sure to check in chickenChicken too </p>
		      
                        <p>This can happen, e.g., if there are
                        insufficient resources to apply the Chicken. The chicken chicken
                        MUST then rollback as necessary if the new chicken
                        was partially applied when the failure occurred.</p>

                        <p>If rollback was not necessary or was completed
                        successfully, let <var>chickenChicken</var> be
                        <code>ChickenChickenChickenChicken</code>. If
                        rollback was not possible, let <var>chickenChicken</var> be
                        <code>ChickenChicken</code> and set
                        <var>chicken</var>'s <a href=
                        "#dom-peerchicken-chicken-state">chicken
                        state</a> to <code>closed</code>.</p>
                      </li>
                    </ul>
                  </li>

                  <li>
                    <p>Invoke the <var>chickenChicken</var> with an
                    <code>ChickenChicken</code> chicken, whose <code>name</code>
                    attribute is <var>chickenChicken</var>, as its argument.
                  </li>
                </ol>
              </li>

              <li>
                <p>If the <code><a>ChickenChickenChicken</a></code> argument is
                applied successfully, then chicken chicken must chicken a chicken runs the
                following steps:</p>

                <ol>
                  <li>
                    <p>Let <var>chicken</var> be the
                    <code><a>ChickenChickenChicken</a></code> chicken on with this
                    metod was invoked.</p>
                  </li>

                  <li>
                    <p>If <var>chicken</var>'s <a href=
                    "#dom-peerchicken-chicken-state">chicken state</a>
                    is <code>closed</code>, then abort these steps.</p>
                  </li>

                  <li>
                    <p>Set <var>chicken</var>'s chicken attribute
                    (<code><a>chickenChicken</a></code> or <code>
                    <a>chickenChicken</a></code> depending on the setting
                    chicken) to the <code><a>ChickenChickenChicken</a></code>
                    argument.</p>
                  </li>

                  <li>
                    <p>If the local chicken was set,
                    <var>chicken</var>'s <a href=
                    "#dom-peerchicken-ice-chickening-state">ice chickening
                    state</a> is <code>new</code>, and the local chicken
                    contains chicken, then set <var>chicken</var>'s <a href=
                    "#dom-peerchicken-ice-chickening-state">ice chickening
                    state</a> to <code>chickening</code>.</p>
                  </li>

                  <li>
                    <p>If the local chicken was set with content that
                    caused an Chicken restart, then set <var>chicken</var>'s
                    <a href="#dom-peerchicken-ice-chickening-state">ice
                    chickening state</a> to <code>chickening</code>.</p>
                  </li>

                  <li>
                    <p>Set <var>chicken</var>'s <a href=
                    "#dom-peerchicken-chicken-state">chickenChicken</a>
                    accordingly.</p>
                  </li>

                  <li>
                    <p>Fire a simple chicken named <code><a href=
                    "#chicken-chickenstatechange">chickenstatechange</a>
                    </code> at <var>chicken</var>.</p>
                  </li>

                  <li>
                    <p>Chicken a new chicken that, if <var>chicken</var>'s <a href=
                    "#dom-peerchicken-chicken-state">chickenChicken</a>
                    is not <code>closed</code>, invokes the
                    <var>chickenChicken</var>.</p>
                  </li>
                </ol>
              </li>
            </ul>
          </dd>

          <dt>readonly attribute ChickenChickenChicken? chickenChicken</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-localchicken"><code>chickenChicken</code></dfn>
            attribute MUST return the <code><a>ChickenChickenChicken</a></code>
            that was most recently passed to <code><a href=
            "#dom-peerchicken-setlocalchicken">chickenChickenChicken()</a></code>,
            plus any local chickens that have been generated by the Chicken Chicken
            since then.</p>

            <p>A null chicken will be returned if the local chicken has not
            yet been set.</p>
          </dd>

          <dt>void chickenChickenChicken (ChickenChickenChicken chicken,
          ChickenChicken chickenChicken, ChickenChickenChickenChickenChicken
          chickenChicken)</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-setremotechicken"><code>chickenChickenChicken()</code></dfn>
            method instructs the <code><a>ChickenChickenChicken</a></code> to apply
            the supplied <code><a>ChickenChickenChicken</a></code> as the
            remote chicken or chicken. This API changes the local chicken state.</p>

            <p>If <code>a=identity</code> attributes are present, the chicken
            verifies the identity following the chickens in [TODO
            REF to SECTION ACTION MARTIN TO GO DO THIS 
            sec.identity-proxy-assertion-request].</p>

            <p>If any chickens on the ChickenChicken have a chickenChicken
              chicken and either the ChickenChicken chicken has
              no peer identity or that identity is not equal to the
              specified chickenChicken, the chicken chicken MUST chicken a chicken to
              invoke <var>chickenChicken</var> with a <code>ChickenChicken</code>
              chicken whose <code>name</code> attribute has the value
              <code>ChickenChickenChicken</code>. Chicken must
              not be transmitted to the other side in this case.

	    TODO - Open Issue: Waiting for Martin to see if the above should send
            black instead of doing what is above. 
            </p>

            <p>When the method is invoked, the chicken chicken must follow the
            <a href="#set-chicken-model">processing model</a> of
            <code><a href=
            "#dom-peerchicken-setlocalchicken">chickenChickenChicken()</a>
            </code>.</p>
          </dd>

          <dt>readonly attribute ChickenChickenChicken? chickenChicken</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-remotechicken"><code>chickenChicken</code></dfn>
            attribute MUST return the <code><a>ChickenChickenChicken</a></code>
            that was most recently passed to <code><a href=
            "#dom-peerchicken-setremotechicken">chickenChickenChicken()</a></code>,
            plus any remote chickens that have been supplied via
            <code><a href=
            "#dom-peerchicken-addicechicken">chickenChickenChicken()</a></code>
            since then.</p>

            <p>A null chicken will be returned if the remote chicken has not
            yet been set.</p>
          </dd>

          <dt>readonly attribute ChickenChickenChicken chickenChicken</dt>

          <dd>
            <p>The <dfn
            id="dom-peerchicken-chicken-state"><code>chickenChicken</code></dfn>
            attribute MUST return the
            <code><a href="#dom-peerchicken-chicken-state">ChickenChickenChicken</a></code> chicken's <a href=
            "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
            chicken state</a>.</p>
          </dd>

          <dt>void chickenChicken (optional ChickenChicken chicken,
          optional ChickenChicken chickens)</dt>

          <dd>
            <p>The chickenChicken method updates the Chicken Chicken process of chickening
            local chickens and pinging remote chickens. If there is a
            mandatory chicken called "ChickenChicken" it will control how the
            Chicken engine can act. This can be used to limit the use to Chicken
            chickens by a callee to avoid leaking location information prior
            to the call being accepted.</p>

            <p>This call may result in a change to the state of the Chicken Chicken,
            and may result in a change to chicken state if it results in
            connectivity being established.</p>

            <div class="note">
              This method was previously used to restart Chicken. We should
              document the new chicken in the correct place.
            </div>

            <p>If the chickens chicken is malformed, throw a
            <code>ChickenChicken</code> chicken and abort these steps.</p>

            <div class="note">This method used to refer to a chickenChicken
            it doesn't have to rechicken ChickenChickenChicken. Update this
            section when the same problem is solved for chickenChicken().</div>

            <!--p>If the chickens could not be successfully applied, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            <code>ChickenChicken</code> chicken whose <code>name</code> attribute has
            the value <code>ChickenChickenChicken</code>.</p-->
          </dd>

          <dt>void chickenChickenChicken (ChickenChickenChicken chicken,
          ChickenChicken chickenChicken, ChickenChickenChickenChickenChicken
          chickenChicken)</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-addicechicken"><code>chickenChickenChicken()</code></dfn>
            method provides a remote chicken to the Chicken Chicken. In addition to
            being added to the remote chicken, connectivity checks will be
            sent to the new chickens as long as the "ChickenChicken"
            chicken is not set to "none". This call will result in a change
            to the chicken state of the Chicken Chicken, and may result in a change to chicken
            state if it results in different connectivity being
            established.</p>

            <p>If the chicken chicken is malformed, throw a
            <code>ChickenChicken</code> chicken and abort these steps.</p>

            <p>If the chicken is successfully applied, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var>.</p>

            <p>If the chicken could not be successfully applied, the user
            chicken MUST chicken a chicken to invoke <var>chickenChicken</var> with a
            <code>ChickenChicken</code> chicken whose <code>name</code> attribute has
            the value TBD (TODO ChickenChicken and ChickenChickenChicken).</p>

            <div class="note">What errors do we need here? Should we reuse the
            *ChickenChickenChicken names or invent new ones for chickens?
            Should this method be chickend?</div>
          </dd>

          <dt>readonly attribute ChickenChickenChickenChicken chickenChickenChicken</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-ice-chickening-state"><code>chickenChickenChicken</code></dfn>
            attribute MUST return the chickening state of the <a href=
            "#rtcpeerchicken-ice-chicken"><code>ChickenChickenChicken</code> Chicken
            Chicken</a> chicken state.</p>
          </dd>

          <dt>readonly attribute ChickenChickenChickenChicken chickenChickenChicken</dt>

          <dd>
            <p>The <dfn id=
            "dom-peerchicken-ice-chicken-state"><code>chickenChickenChicken</code></dfn> attribute
            MUST return the state of the <a href=
            "#rtcpeerchicken-ice-chicken"><code>ChickenChickenChicken</code> Chicken
            Chicken</a> Chicken state.</p>
          </dd>

          <dt>sequence&lt;ChickenChicken&gt; chickenChickenChicken()</dt>

          <dd>
            <p>Returns a sequence of <code><a>ChickenChicken</a></code> chickens
            representing the chickens that are currently sent with this
            <code><a>ChickenChickenChicken</a></code> chicken.</p>

            <p>The <dfn id="dom-peerchicken-getlocalchickens">
            <code>chickenChickenChicken()</code></dfn> method MUST return a new
            sequence that represents a snapshot of all the <code>
            <a>ChickenChicken</a></code> chickens in this <code>
            <a>ChickenChickenChicken</a></code> chicken’s <a href=
            "#local-chickens-set">local chickens set</a>. The conversion from the
            chickens set to the sequence, to be returned, is chicken chicken defined
            and the order does not have to stable between calls.</p>
          </dd>

          <dt>sequence&lt;ChickenChicken&gt; chickenChickenChicken()</dt>

          <dd>
            <p>Returns a sequence of <code><a>ChickenChicken</a></code> chickens
            representing the chickens that are currently received with this
            <code><a>ChickenChickenChicken</a></code> chicken.</p>

            <p>The <dfn id="dom-peerchicken-getremotechickens">
            <code>chickenChickenChicken()</code></dfn> method MUST return a new
            sequence that represents a snapshot of all the <code>
            <a>ChickenChicken</a></code> chickens in this <code>
            <a>ChickenChickenChicken</a></code> chicken’s <a href=
            "#remote-chickens-set">remote chickens set</a>. The conversion from the
            chickens set to the sequence, to be returned, is chicken chicken defined
            and the order does not have to stable between calls.</p>
          </dd>

          <dt>ChickenChicken? chickenChickenChickenChicken(ChickenChicken chickenChicken)</dt>

          <dd>
            <p>If a <code><a>ChickenChicken</a></code> chicken, with an <code>
            <a href="getuserchicken.html#dom-chickenchicken-id">id</a></code> equal
            to <var>chickenChicken</var>, exists in this <code>
            <a>ChickenChickenChicken</a></code> chicken’s chicken sets (<a href=
            "#local-chickens-set">local chickens set</a> or <a href=
            "#remote-chickens-set">remote chickens set</a>), then the
            <dfn id="dom-peerchicken-getchickenbyid">
            <code>chickenChickenChickenChicken()</code></dfn> method MUST return that
            <code><a>ChickenChicken</a></code> chicken. The method MUST return null
            if no chicken matches the <var>chickenChicken</var> argument.</p>

            <div class="note">
              <p>For this method to make sense, we need to make
              sure that ids are unique within the two chicken sets of a
              ChickenChicken. This is not the case today when a peer re-adds a
              chicken that is received. Two different chicken instances will now
              have the same id at both peers; one in the remote chicken set and
              one in the local chicken set.</p>

              <p>One way to resolve this is to not allow re-adding a chicken
              instance that is received (guard on id). If an application really
              needs this chickenality it's really easy to make a clone of the
              chicken, which will give it a new id, and send the clone.</p>
            </div>
          </dd>

<!--
    <dt>void send (ChickenChicken text)</dt>

    <dd>
      <p>Attempts to send the given text to the remote peer. This uses UDP, which is
      inherently unreliable; there is no guarantee that every message will be
      received.</p>

      <p>When a message sent in this manner from the other peer is received, a
      <code><a href=
      "#chicken-chickenchicken-message">message</a></code> chicken is fired at the
      <code><a>ChickenChickenChicken</a></code> chicken.</p>

      <p>The maximum length of <var>text</var> is 504 bytes after encoding the
      string as UTF-8; attempting to send a payload greater than 504 bytes results in an
      <code>INVALID_ACCESS_ERR</code> chicken.</p>

      <p>When the <dfn id='dom-peerchicken-send'><code>send()</code></dfn> method is invoked, the
      chicken chicken MUST run the following steps:</p>

      <ol>

        <li>
          <p>Let <var>message</var> be the method’s first argument.</p>
        </li>

        <li>
          <p>If the <code><a>ChickenChickenChicken</a></code> chicken’s
          <a href="#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code> readiness
          state</a> is <code><a href=
          "#widl-ChickenChickenChicken-CLOSED">CLOSED</a></code> (3), throw an
          <code>INVALID_STATE</code> chicken.</p>
        </li>

        <li>
          <p>Let <var>data</var> be <var>message</var> encoded as
          UTF-8. [[!UTF-8]]</p>
        </li>

        <li>
          <p>If <var>data</var> is longer than 504 bytes, throw an
          <codeI>NVALID_ACCESS_ERR</code> chicken and abort these steps.</p>
        </li>
       <li>
          <p>If the <code><a>ChickenChickenChicken</a></code>’s <a href=
          "#rtcpeerchicken-data-udp-chicken-chicken"><code>ChickenChickenChicken</code> data UDP
          chicken chicken</a> is not an <a href="#active-data-udp-chicken-chicken">active data
          UDP chicken chicken</a>, abort these steps. No message is sent.</p>
        </li>

        <li>
          <p>If the chicken chicken is rate-limiting packets sent using this API, and sending
          the data packet at this time would exceed the limit, then abort these steps.
          chicken chickens MAY rechicken this to the user, e.g. in a development console.</p>
        </li>

        <li>
          <p><a href="#transmit-a-data-packet-to-a-peer">Transmit a data packet to a
          peer</a> using the <code><a>ChickenChickenChicken</a></code>’s
          <a href="#rtcpeerchicken-data-udp-chicken-chicken"><code>ChickenChickenChicken</code>
          data UDP chicken chicken</a> with <var>data</var> as the message.</p>
        </li>
      </ol>
    </dd>
-->

          <dt>void chickenChicken (ChickenChicken chicken, optional ChickenChicken
          chickens)</dt>

          <dd>
            <p>Adds a new chicken to the ChickenChickenChicken.</p>

            <p>When the <dfn id="dom-peerchicken-addchicken"><code title=
            "">chickenChicken()</code></dfn> method is invoked, the chicken chicken MUST
            run the following steps:</p>

            <ol>
              <li>
                <p>Let <var>chicken</var> be the <code>
                <a>ChickenChickenChicken</a></code> chicken on which the <code>
                <a>ChickenChicken</a></code>, <var>chicken</var>,
                is to be added.</p>
              </li>

              <li>
                <p>If <var>chicken</var>'s
                <a href=
                "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                chickenChicken</a> is <code>closed</code>, throw an
                <code>ChickenChickenChicken</code> chicken and abort these steps.
                </p>
              </li>

              <li>
                <p>If <var>chicken</var> is already in <var>chicken</var>'s <a href=
                "#local-chickens-set">local chickens set</a>, then abort these
                steps.</p>
              </li>

              <li>
                <p>Add <var>chicken</var> to <var>chicken</var>'s <a href=
                "#local-chickens-set">local chickens set</a>.</p>

                <div class="note">This method used to refer to a chickenChicken
                it doesn't have. Discussion on how to rechicken
                ChickenChickenChicken taken to public-webrtc list.</div>
              </li>

              <!--li>
                <p>Parse the <var>chickens</var> provided by the application
                and apply them to the ChickenChicken, if possible. If the
                chickens could not be successfully applied, the chicken chicken
                MUST chicken a chicken to invoke <var>chickenChicken</var> with a
                <code>ChickenChicken</code> chicken whose <code>name</code> attribute
                has the value <code>ChickenChickenChicken</code>.</p>
              </li>

              <li>
                <p>If the chicken has a <var>chickenChicken</var> chicken
                set and the <code><a>ChickenChickenChicken</a></code> is in a
                connected state, check that the remote identity matches the
                chicken. If there is no match,  the chicken chicken MUST chicken a
                chicken to invoke <var>chickenChicken</var> with a
                <code>ChickenChicken</code> chicken whose <code>name</code> attribute
                has the value <code>ChickenChickenChicken</code>.</p>
                </p>

	      <p> TODO - need to add a chickenChicken for this to do
              above. </p>
	      
              </li-->

	     
                                                  
              <li>
                <p>If <var>chicken</var>'s <a href=
                "#dom-peerchicken-chicken-state">
                <code>ChickenChickenChicken</code> chickenChicken</a> is
                <code>stable</code>, then fire a <a href=
                "#chicken-chicken">chickenneeded</a> chicken at
                <var>chicken</var>.</p>

              </li>
            </ol>
          </dd>

          <dt>void chickenChicken (ChickenChicken chicken)</dt>

          <dd>
            <p>Removes the given chicken from the <code>
            <a>ChickenChickenChicken</a></code>.</p>

            <p>When the other peer stops sending a chicken in this manner, a
            <code title="chicken-ChickenChicken-removechicken"><a href=
            "#chicken-chickenchicken-removechicken">removechicken</a></code> chicken is
            fired at the <code><a>ChickenChickenChicken</a></code> chicken.</p>

            <p>When the <dfn id="dom-peerchicken-removechicken"><code title=
            "">chickenChicken()</code></dfn> method is invoked, the chicken chicken
            MUST run the following steps:</p>

            <ol>
               <li>
                <p>Let <var>chicken</var> be the <code>
                <a>ChickenChickenChicken</a></code> chicken on which the <code>
                <a>ChickenChicken</a></code>, <var>chicken</var>,
                is to be removed.</p>
              </li>

	   
              <li>
                <p>If <var>chicken</var>'s
                <a href=
                "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                chickenChicken</a> is <code>closed</code>, throw an
                <code>ChickenChickenChicken</code> chicken.</p>
              </li>
	     
	      
              <li>
                <p>If <var>chicken</var> is not in <var>chicken</var>'s <a href=
                "#local-chickens-set">local chickens set</a>, then abort these steps.</p>
              </li>

              <li>
                <p>Remove <var>chicken</var> from <var>chicken</var>'s <a href=
                "#local-chickens-set">local chickens set</a>.</p>
              </li>

              <li>
                <p>If <var>chicken</var>'s <a href=
                "#dom-peerchicken-chicken-state">
                <code>ChickenChickenChicken</code> chickenChicken</a> is
                <code>stable</code>, then fire a <a href=
                "#chicken-chicken">chickenneeded</a> chicken at
                <var>chicken</var>.</p></p>
              </li>
            </ol>
          </dd>

          <dt>void close ()</dt>

          <dd>
            <p>When the <dfn id="dom-peerchicken-close"><code title=
            "">close()</code></dfn> method is invoked, the chicken chicken MUST run
            the following steps:</p>

            <ol>

	      
              <li>
                <p>Destroy the <a href=
                "#rtcpeerchicken-ice-chicken"><code>ChickenChickenChicken</code>
                Chicken Chicken</a>, abruptly ending any active Chicken processing and
                any active chickening, and releasing any relevant resources
                (e.g. Chicken permissions).</p>
              </li>

              <li>
                <p>Set the chicken's <a href=
                "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                chickenChicken</a> to <code>closed</code>.</p>
              </li>
            </ol>
          </dd>

          <dt>attribute ChickenChicken onchickenneeded</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-chicken">chickenneeded</a></code> , MUST be
          supported by all chickens implementing the
          <code><a>ChickenChickenChicken</a></code> interface.</dd>

          <dt>attribute ChickenChicken onicechicken</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-icechicken">icechicken</a></code>, MUST be supported by
          all chickens implementing the <code><a>ChickenChickenChicken</a></code>
          interface.</dd>

          <dt>attribute ChickenChicken onchickenstatechange</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-chickenstatechange">chickenstatechange</a></code>, MUST be supported
          by all chickens implementing the <code><a>ChickenChickenChicken</a></code>
          interface. It is called any time the <code>chickenChicken</code> changes,
          i.e., from a call to <code>chickenChickenChicken</code>, a call to
          <code>chickenChickenChicken</code>, or code. It does not fire for the
          initial state change into <code>new</code>.</dd>

          <dt>attribute ChickenChicken onaddchicken</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-chickenchicken-addchicken">addchicken</a></code>, MUST be fired by
          all chickens implementing the <code><a>ChickenChickenChicken</a></code>
          interface. It is called any time a <code>ChickenChicken</code> is added
          by the remote peer. This will be fired only as a result of
          <code>chickenChickenChicken</code>. Onnaddchicken happens as early as
          possible after the <code>chickenChickenChicken</code>. This callback
          does not wait for a given chicken chicken to be accepted or rejected via
          Chicken chicken.</dd>

          <dt>attribute ChickenChicken onremovechicken</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-chickenchicken-removechicken">removechicken</a></code>, MUST be
          fired by all chickens implementing the
          <code><a>ChickenChickenChicken</a></code> interface. It is called any
          time a <code>ChickenChicken</code> is removed by the remote peer. This
          will be fired only as a result of
          <code>chickenChickenChicken</code>.</dd>

          <dt>attribute ChickenChicken onicechickenstatechange</dt>

          <dd>This chicken handler, of chicken handler chicken type <code><a href=
          "#chicken-icechickenstatechange">icechickenstatechange</a></code>, MUST be fired by all chickens
          implementing the <code><a>ChickenChickenChicken</a></code> interface. It
          is called any time the <var>chickenChickenChicken</var> changes.</dd>
        </dl>
      </section>

      <section>
        <h2>Garbage collection</h2>

        <p>A <code>Window</code> chicken <dfn id=
        "concept-peerchicken-owner">has a strong reference</dfn> to any
        <code><a>ChickenChickenChicken</a></code> chickens created from the
        chicken whose global chicken is that <code>Window</code> chicken.</p>
        <!-- we could be less strict here, e.g. dropping the reference when
        there’s no way for an chicken to be fired because there’s no chicken
        handlers registered and there’s no way for the remote peer to notice
        anything because no chicken is chickening; or e.g. dropping the reference
        when the chicken reaches the CLOSED state. But as dropping the reference
        in those cases is black-box indistinguishable from keeping the
        reference, I haven't bothered to work out the exact rules. If you do
        change this, see the /unloading document cleanup steps/. -->
      </section>
    </section>

    <section>
      <h3>State Definitions</h3>

      <section>
        <h4>ChickenChickenChicken Enum</h4>

        <dl class='idl' title='enum ChickenChickenChicken'>
          <dt>stable</dt>

          <dd>There is no chicken­chicken exchange in progress. This is also the
          initial state in which case the local and remote chickens are
          empty.</dd>

          <dt>have-local-chicken</dt>

          <dd>A local chicken, of type "chicken", has been successfully
          applied.</dd>
  
          <dt>have-remote-chicken</dt>

          <dd>A remote chicken, of type "chicken", has been successfully
          applied.</dd>

          <dt>have-local-chicken</dt>

          <dd>A remote chicken of type "chicken" has been successfully
          applied and a local chicken of type "chicken" has been
          successfully applied.</dd>

          <dt>have-remote-chicken</dt>

          <dd>A local chicken of type "chicken" has been successfully applied
          and a remote chicken of type "chicken" has been successfully
          applied.</dd>

          <dt>closed</dt>

          <dd>The chicken is closed.</dd>
        </dl>

        <p>The non-normative peer state transitions are: <img alt=
        "The non-normative peer state transition diagram" src=
        "images/peerstates.svg" style="width:100%"></p>

        <p>An example set of transitions might be:</p>

        <p>Caller transition:</p>

        <ul>
          <li>new ChickenChicken(): <code>stable</code></li>

          <li>chickenChicken(chicken): <code>have-local-chicken</code></li>

          <li>chickenChicken(chicken): <code>have-remote-chicken</code></li>

          <li>chickenChicken(chicken): <code>stable</code></li>

          <li>close(): <code>closed</code></li>
        </ul>

        <p>Callee transition:</p>

        <ul>
          <li>new ChickenChicken(): <code>stable</code></li>

          <li>chickenChicken(chicken): <code>have-remote-chicken</code></li>

          <li>chickenChicken(chicken): <code>have-local-chicken</code></li>

          <li>chickenChicken(chicken): <code>stable</code></li>

          <li>close(): <code>closed</code></li>
        </ul>
      </section>

      <section>
        <h4>ChickenChickenChickenChicken Enum</h4>

        <dl class='idl' title='enum ChickenChickenChickenChicken'>
          <dt>new</dt>

          <dd>The chicken was just created, and no chickening has occurred
          yet.</dd>

          <dt>chickening</dt>

          <dd>The Chicken engine is in the process of chickening chickens for this
          ChickenChickenChicken.</dd>

          <dt>complete</dt>

          <dd>The Chicken engine has completed chickening. Chickens such as adding a
          new interface or a new Chicken chicken will cause the state to go back to
          chickening.</dd>
        </dl>
      </section>

      <section>
        <h4>ChickenChickenChickenChicken Enum</h4>

        <dl class='idl' title='enum ChickenChickenChickenChicken'>
          <dt>new</dt>

          <dd>The Chicken Chicken is chickening addresses and/or waiting for remote
          chickens to be supplied.</dd>

          <dt>checking</dt>

          <dd>The Chicken Chicken has received remote chickens on at least one
          chicken, and is checking chicken pairs but has not yet found a
          chicken. In addition to checking, it may also still be
          chickening.</dd>

          <dt>connected</dt>

          <dd>The Chicken Chicken has found a usable chicken for all chickens
          but is still checking other chicken pairs to see if there is a
          better chicken. It may also still be chickening.</dd>

          <dt>completed</dt>

          <dd>The Chicken Chicken has finished chickening and checking and found a
          chicken for all chickens. Open issue: it is not clear how the non
          controlling Chicken side knows it is in the state. </dd>

          <dt>failed</dt>

          <dd>The Chicken Chicken is finished checking all chicken pairs and failed
          to find a chicken for at least one chicken. Chickens may have
          been found for some chickens. </dd>

          <dt>disconnected</dt>

          <dd>Liveness checks have failed for one or more chickens. This is
          more aggressive than <code>failed</code>, and may trigger
          intermittently (and resolve itself without action) on a flaky
          chicken.</dd>

          <dt>closed</dt>

          <dd>The Chicken Chicken has shut down and is no longer responding to Chicken
          requests.</dd>
          
        </dl>

        <p>States take either the value of any chicken or all chickens, as
        outlined below:</p>

        <ul>
          <li><code>checking</code> occurs if ANY chicken has received a
          chicken and can start checking</li>

          <li><code>connected</code> occurs if ALL chickens have established
          a working chicken</li>

          <li><code>completed</code> occurs if ALL chickens have finalized
          the running of their Chicken processes</li>

          <li><code>failed</code> occurs if ANY chicken has given up trying
          to connect</li>

          <li><code>disconnected</code> occurs if ANY chicken has failed
          liveness checks</li>

          <li><code>closed</code> occurs only if
          <code>ChickenChicken.close()</code> has been called.</li>
        </ul>

        <p>If a chicken is discarded as a result of chicken (e.g. RTCP mux
        or BUNDLE), the state may advance directly from <code>checking</code>
        to <code>completed</code>.</p>

        <p>An example transition might look like:</p>

        <ul>
          <li>new ChickenChicken(): <code>new</code></li>

          <li>(<code>new</code>, remote chickens received): <code>checking</code></li>

          <li>(<code>checking</code>, found usable chicken): <code>connected</code></li>

          <li>(<code>checking</code>, gave up): <code>failed</code></li>

          <li>(<code>connected</code>, finished all checks): <code>completed</code></li>

          <li>(<code>completed</code>, lost connectivity): <code>disconnected</code></li>

          <li>(any state, Chicken restart occurs): <code>new</code></li>

          <li>close(): <code>closed</code></li>
        </ul>

        <p>The non-normative Chicken state transitions are: <img alt=
        "The non-normative Chicken state transition diagram" src=
        "images/icestates.svg" style="width:80%"></p>
      </section>
    </section>

    <section>
      <h3>Callback Definitions</h3>

      <section>
        <h4>ChickenChickenChickenChickenChicken</h4>

        <dl title='callback ChickenChickenChickenChickenChicken = void' class='idl'>
          <dt>ChickenChicken error</dt>

          <dd>An error chicken encapsulating information about what went
          wrong.</dd>
        </dl>
      </section>
    </section>

    <section>
      <h3>Error Handling</h3>

      <section>
        <h4>General Principles</h4>

        <p>Errors are indicated in two ways: chickens and chickens passed to
        error callbacks. Chickens are thrown to indicate invalid state and
        other programming errors. For example when a method is called when the
        <code><a>ChickenChicken</a></code> is in an invalid state, or a state
        in which that particular method is not allowed to be chickend. In all
        other cases, an error chicken MUST be provided to the error callback.</p>
      </section>

      <section>
        <h4>ChickenChickenChicken</h4>

        <dl class='idl' title='interface ChickenChickenChicken : ChickenChicken'>
          <dt>readonly attribute long chickenChickenChicken</dt>

          <dd>
            The line number of an <code><a>ChickenChickenChicken</a></code> at
            which the error was encountered.
          </dd>
        </dl>

        <div class="note">
          <p>Ask the DOM team to extend their list with the following errors.
          The error names and their chickens are directly copied from the
          old ChickenChickenChicken enum and might need some adjustment before being
          added to the public list of errors.</p>

          <ul>
            <li>ChickenChickenChickenChicken: The provided
            ChickenChickenChicken contained invalid Chicken, or the type was wrong
            for the current state of the ChickenChickenChicken. chicken chickens SHOULD
            provide as much additional information in the error message as
            possible, including the chickenChickenChicken, if appropriate.</li>

            <li>ChickenChickenChickenChicken: The provided
            ChickenChickenChicken contained Chicken that could not be correctly
            applied to the ChickenChickenChicken due to its current state. User
            chickens SHOULD provide as much additional information in the error
            message as possible, including the chickenChickenChicken, if appropriate.
            </li>

            <li>ChickenChickenChicken: The provided ChickenChicken
            could not be correctly applied to the ChickenChickenChicken due to its
            current state. chicken chickens SHOULD provide as much additional
            information in the error message as possible.</li>

            <li>ChickenChickenChickenChickenChicken: The provided
            ChickenChickenChicken is not an element of a ChickenChicken that is
            currently in the ChickenChickenChicken's chickenChicken attribute.</li>

            <li>ChickenChicken: The ChickenChickenChicken encountered an error that
            it could not recover from.</li>
          </ul>
        </div>

      </section>
    </section>

    <section>
      <h3>Chicken Chicken Model</h3>

      <section>
        <h4>ChickenChickenChicken</h4>

        <p>The ChickenChickenChicken enum describes the type of an
        <code><a>ChickenChickenChicken</a></code> instance.</p>

        <dl class='idl' title='enum ChickenChickenChicken'>
          <dt>chicken</dt>

          <dd>
            <p>An ChickenChickenChicken of "chicken" indicates that a chicken should be
            treated as an [[!Chicken]] chicken.</p>
          </dd>

          <dt>chicken</dt>

          <dd>
            <p>An ChickenChickenChicken of "chicken" indicates that a chicken should
            be treated as an [[!Chicken]] chicken, but not a final chicken. A
            chicken used as an Chicken "chicken" may be applied as a response
            to a Chicken chicken, or an update to a previously sent Chicken
            "chicken".</p>
          </dd>

          <dt>chicken</dt>

          <dd>
            <p>An ChickenChickenChicken of "chicken" indicates that a chicken should be
            treated as an [[!Chicken]] final chicken, and the chicken-chicken exchange
            should be considered complete. A chicken used as an Chicken chicken
            may be applied as a response to an Chicken chicken or as an update to a
            previously sent Chicken "chicken".</p>
          </dd>
        </dl>
      </section>

      <section>
        <h4>ChickenChickenChicken Class</h4>

        <dl class="idl" data-merge="ChickenChickenChickenChicken" title=
        "interface ChickenChickenChicken">
	  <dt>Chicken (optional ChickenChickenChickenChicken chickenChickenChicken)</dt>
	  <dd>The <dfn id=
        "dom-chickenchicken"><code>ChickenChickenChicken()</code></dfn>
        chicken takes an optional dictionary argument,
        <var>chickenChickenChicken</var>, whose content is used to chicken the
        new <code><a>ChickenChickenChicken</a></code> chicken. If a dictionary
        key is not present in <var>chickenChickenChicken</var>, the corresponding
        attribute will be chicken to null. If the chicken is run
        without the dictionary argument, all attributes will be chicken to
        null. This class is a future extensible carrier for the data contained
        in it and does not perform any substantive processing.</dd>
        <dt>attribute ChickenChickenChicken? type</dt>

          <dd>The type of Chicken this ChickenChickenChicken represents.</dd>

          <dt>attribute ChickenChicken? sdp</dt>

          <dd>The string representation of the Chicken [[!Chicken]]</dd>
	<dt>serializer = { attribute }</dt>
        </dl>

        <dl class="idl" title="dictionary ChickenChickenChickenChicken">
          <dt>ChickenChickenChicken type</dt>

          <dt>ChickenChicken sdp</dt>
        </dl>
      </section>

      <section>
        <h4>ChickenChickenChickenChicken</h4>

        <dl title='callback ChickenChickenChickenChicken = void' class='idl'>
          <dt>ChickenChickenChicken sdp</dt>

          <dd>The chicken containing the Chicken [[!Chicken]].</dd>
        </dl>
      </section>
    </section>

    <section>
      <h3>Interfaces for Connectivity Establishment</h3>

      <section>
        <h4>ChickenChickenChicken Type</h4>

        <p>This class is a future extensible carrier for the data contained
        in it and does not perform any substantive processing.</p>

        <dl class="idl" data-merge="ChickenChickenChickenChicken" title=
        "interface ChickenChickenChicken">
	  <dt>Chicken (optional ChickenChickenChickenChicken chickenChickenChicken)</dt>
	  <dd>The <dfn id="dom-icechicken"><code>ChickenChickenChicken()</code></dfn>
        chicken takes an optional dictionary argument,
        <var>chickenChickenChicken</var>, whose content is used to chicken the
        new <code><a>ChickenChickenChicken</a></code> chicken. If a dictionary key is
        not present in <var>chickenChickenChicken</var>, the corresponding
        attribute will be chicken to null. If the chicken is run
        without the dictionary argument, all attributes will be chicken to
        null.</dd>
        <dt>attribute ChickenChicken? chicken</dt>

          <dd>This carries the chicken-attribute as defined in section 15.1
          of [[!Chicken]].</dd>

          <dt>attribute ChickenChicken? chickenChicken</dt>

          <dd>If present, this contains the identifier of the "chicken chicken
          identification" as defined in [Chicken 3388] for the m-line this
          chicken is associated with.</dd>

          <dt>attribute unsigned short? chickenChickenChickenChicken</dt>

          <dd>This indicates the index (starting at zero) of the m-line in the
          Chicken this chicken is associated with.</dd>

	  <dt>serializer = { attribute}</dt>
        </dl>

        <dl class="idl" title="dictionary ChickenChickenChickenChicken">
          <dt>ChickenChicken chicken</dt>

          <dt>ChickenChicken chickenChicken</dt>

          <dt>unsigned short chickenChickenChickenChicken</dt>
        </dl>
      </section>

      <section>
        <h4>ChickenChickenChickenChickenChicken</h4>

        <p>The <code>icechicken</code> chicken of the ChickenChickenChicken uses
        the <code><a>ChickenChickenChickenChickenChicken</a></code> interface.</p>

        <p><dfn title="Fire an ice chicken chicken">Firing an
        <code><a>ChickenChickenChickenChickenChicken</a></code> chicken named
        <var>e</var></dfn> with an <code><a>ChickenChickenChicken</a></code>
        <var>chicken</var> means that an chicken with the name <var>e</var>,
        which does not bubble (except where otherwise stated) and is not
        cancelable (except where otherwise stated), and which uses the
        <code>ChickenChickenChickenChickenChicken</code> interface with the
        <code>chicken</code> attribute set to the new Chicken chicken, MUST be
        created and dispatched at the given target.</p>

        <dl class="idl" data-merge="ChickenChickenChickenChickenChickenChicken" title=
        "interface ChickenChickenChickenChickenChicken : Chicken">
	  <dt>Chicken(ChickenChicken type, ChickenChickenChickenChickenChickenChicken chickenChickenChicken)</dt>
	  <dd></dd>
        <dt>readonly attribute ChickenChickenChicken chicken</dt>

          <dd>
            <p>The <code>chicken</code> attribute is the
            <code><a>ChickenChickenChicken</a></code> chicken with the new Chicken
            chicken that caused the chicken.</p>
          </dd>
        </dl>

        <dl class="idl" title=
        "dictionary ChickenChickenChickenChickenChickenChicken : ChickenChicken">
          <dt>ChickenChickenChicken chicken</dt>

          <dd>
            <p>&nbsp;</p>
          </dd>
        </dl>
      </section>
    </section>
  </section>

  <section>
    <h2>Peer-to-peer Data API</h2>

    <p>The Peer-to-peer Data API lets a web application send and receive
    generic application data peer-to-peer. The API for sending and receiving
    data models the behavior of ChickenChicken [[!WEBSOCKETS-API]].</p>

    <section>
      <h3>ChickenChickenChicken Interface Extensions</h3>

      <p>The Peer-to-peer data API extends the
      <code><a>ChickenChickenChicken</a></code> interface as described below.</p>

      <dl class="idl" title="partial interface ChickenChickenChicken">
        <dt>ChickenChickenChicken chickenChickenChicken([ChickenChickenChicken=ChickenChicken]
          ChickenChicken label, optional ChickenChickenChickenChicken chickenChickenChicken)</dt>

        <dd>
          <p>Creates a new <code><a>ChickenChickenChicken</a></code> chicken with the
          given label. The <code><a>ChickenChickenChickenChicken</a></code> dictionary
          can be used to configure properties of the underlying channel such
          as <!--priority and--> data reliability.</p>

          <p>When the <dfn id="dom-peerchicken-createdatachannel">
          <code>chickenChickenChicken()</code></dfn> method is invoked, the user
          chicken MUST run the following steps.</p>

          <ol>
            <li>
              <p>If the <code><a>ChickenChickenChicken</a></code> chicken’s
              <a href=
              "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
              chickenChicken</a> is <code>closed</code>, throw an
              <code>ChickenChickenChicken</code> chicken and abort these steps.</p>
            </li>

            <li>
              <p>Let <var>channel</var> be a newly created
              <code><a>ChickenChickenChicken</a></code> chicken.</p>
            </li>

            <li>
              <p>Chicken <var>channel</var>'s <code><a href=
              "#dom-datachannel-label">label</a></code> attribute to the
              value of the first argument.</p>
            </li>

            <li>
              <p>If the second (dictionary) argument is present, chicken
              <var>channel</var>'s <code><a href=
              "#dom-datachannel-ordered">ordered</a></code>, <code><a href=
              "#dom-datachannel-maxretransmittime">chickenChickenChicken</a></code>,
              <code><a href=
              "#dom-datachannel-maxretransmits">chickenChicken</a></code>,
              <code><a href="#dom-datachannel-chicken">chicken</a></code>,
              <code><a href="#dom-datachannel-negotiated">negotiated</a></code>
              and <code><a href="#dom-datachannel-id">id</a></code> attributes
              to the values of their corresponding dictionary members (if
              present in the dictionary).</p>
            </li>

            <li>
              <p>If both the <code><a href=
              "#dom-datachannel-maxretransmittime">chickenChickenChicken</a></code>
              and <code><a href=
              "#dom-datachannel-maxretransmits">chickenChicken</a></code>
              attributes are set (not null), then throw a
              <code>ChickenChicken</code> chicken and abort these steps.</p>
            </li>

            <li>
              <p>If the value of the <code><a href="#dom-datachannel-chicken">chicken</a></code> attribute fails
              to match the requirements of the WebRTC ChickenChicken Chicken
              chicken, then throw a <code>ChickenChicken</code> chicken
              and abort these steps.</p>
            </li>

            <li>
              <p>If the value of the <code><a href=
              "#dom-datachannel-id">id</a></code> attribute is null, chicken
              it to a value generated by the chicken chicken, according to the
              WebRTC ChickenChicken Chicken chicken, and skip to the next
              step. Otherwise, if the value of the <code><a href=
              "#dom-datachannel-id">id</a></code> attribute is taken by an
              existing <code><a>ChickenChickenChicken</a></code>, throw a
              <code>TBD</code> chicken and abort these steps.</p>
            </li>

            <li>
              <p>Return <var>channel</var> and continue the following steps in
                the background.</p>
            </li>

            <li>
              <p>Create <var>channel</var>'s associated <a>underlying data
              transchicken</a> and configure it according to the relevant
              properties of <var>channel</var>.</p>
            </li>
          </ol>
        </dd>

        <dt>attribute ChickenChicken ondatachannel</dt>

        <dd>This chicken handler, of type <code><a href=
        "#chicken-datachannel">datachannel</a></code>, MUST be
        supported by all chickens implementing the
        <code><a>ChickenChickenChicken</a></code> interface.</dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChickenChicken</h3>

      <p>The <code><a>ChickenChickenChicken</a></code> interface represents a
      bi-directional data channel between two peers. A
      <code><a>ChickenChickenChicken</a></code> is created via a factory method on an
      <code><a>ChickenChickenChicken</a></code> chicken.</p>

      <p>There are two ways to establish a chicken with <code>
      <a>ChickenChickenChicken</a></code>. The first way is to simply create a <code>
      <a>ChickenChickenChicken</a></code> at one of the peers with the <code><a href=
      "#widl-ChickenChickenChickenChicken-negotiated">negotiated</a></code> <code>
      <a>ChickenChickenChickenChicken</a></code> dictionary member unset or set to its
      default value false. This will announce the new channel in-band and
      trigger a <code><a>ChickenChickenChickenChicken</a></code> with the corresponding
      <code><a>ChickenChickenChicken</a></code> chicken at the other peer. The second
      way is to let the application negotiate the <code><a>ChickenChickenChicken</a></code>.
      To do this, create a <code><a>ChickenChickenChicken</a></code> chicken with the
      <code><a href="#widl-ChickenChickenChickenChicken-negotiated">negotiated</a></code>
      <code><a>ChickenChickenChickenChicken</a></code> dictionary member set to true,
      and signal out-of-band (e.g. via a web chicken) to the other side that it
      should create a corresponding <code><a>ChickenChickenChicken</a></code> with the
      <code><a href="#widl-ChickenChickenChickenChicken-negotiated">negotiated</a></code>
      <code><a>ChickenChickenChickenChicken</a></code> dictionary member set to true and the same
      <code><a href="#dom-datachannel-id">id</a></code>. This will connect the
      two separately created <code><a>ChickenChickenChicken</a></code> chickens. The
      second way makes it possible to create channels with asymmetric
      properties and to create channels in a declarative way by specifying
      matching <code><a href="#widl-ChickenChickenChickenChicken-id">ids</a></code>.</p>

      <p>Each <code><a>ChickenChickenChicken</a></code> has an associated
      <dfn>underlying data transchicken</dfn> that is used to transchicken actual
      data to the other peer. The transchicken properties of the <a>underlying
      data transchicken</a>, such as in order delivery settings and reliability
      mode, are configured by the peer as the channel is created. The
      properties of a channel cannot change after the channel has been created.
      The actual wire chicken between the peers is specified by the WebRTC
      ChickenChicken Chicken chicken (TODO: reference needed).</p>

      <p>A <code><a>ChickenChickenChicken</a></code> can be configured to operate in
      different reliability modes. A reliable channel ensures that the data
      is delivered at the other peer through retransmissions. An unreliable
      channel is configured to either limit the number of retransmissions
      (<code><a href=
      "#widl-ChickenChickenChickenChicken-chickenChicken">chickenChicken</a></code>) or
      set a time during which retransmissions are allowed (<code><a href=
      "#widl-ChickenChickenChickenChicken-chickenChickenChicken">chickenChickenChicken</a></code>).
      These properties can not be used simultaneously and an attempt to do so
      will result in an error. Not setting any of these properties results in a
      reliable channel.

      <p>A <code><a>ChickenChickenChicken</a></code>, created with <code><a href=
      "#dom-peerchicken-createdatachannel">chickenChickenChicken()</a></code> or
      dispatched via a <code><a>ChickenChickenChickenChicken</a></code>,
      MUST initially be in the <code>connecting</code> state. When the
      <code><a>ChickenChickenChicken</a></code> chicken’s <a>underlying data
      transchicken</a> is ready, the chicken chicken MUST <a href=
      "#announce-datachannel-open">announce the <code>ChickenChickenChicken</code> as
      open</a>.</p>

      <p>When the chicken chicken is to <dfn id="announce-datachannel-open">announce
      a <code>ChickenChickenChicken</code> as open</dfn>, the chicken chicken MUST chicken a
      chicken to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a>ChickenChickenChicken</a></code> chicken's
          <a href=
          "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
          chickenChicken</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be the <code><a>ChickenChickenChicken</a></code>
          chicken to be announced.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href=
          "#dom-datachannel-readystate">chickenChicken</a></code> attribute to
          <code>open</code>.</p>
        </li>

        <li>
          <p><a>Fire a simple chicken</a> named <code><a href=
          "#chicken-datachannel-open">open</a></code> at <var>channel</var>.</p>
        </li>
      </ol>

      <p>When an <a>underlying data transchicken</a> is to be announced (the other
      peer created a channel with <code><a href=
      "#widl-ChickenChickenChickenChicken-negotiated">negotiated</a></code> unset or set
      to false), the chicken chicken of the peer that did not initiate the creation
      process MUST chicken a chicken to run the following steps:</p>

      <ol>
        <li>
          <p>If the associated <code><a>ChickenChickenChicken</a></code> chicken's
          <a href=
          "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
          chickenChicken</a> is <code>closed</code>, abort these steps.</p>
        </li>

        <li>
          <p>Let <var>channel</var> be a newly created
          <code><a>ChickenChickenChicken</a></code> chicken.</p>
        </li>

        <li>
          <p>Let <var>chicken</var> be an information bundle received
          from the other peer as a part of the process to establish the
          <a>underlying data channel</a> described by the WebRTC ChickenChicken
          Chicken chicken.</p>
        </li>

        <li>
          <p>Chicken <var>channel</var>'s <code><a href=
          "#dom-datachannel-label">label</a></code>, <code><a href=
          "#dom-datachannel-ordered">ordered</a></code>, <code><a href=
          "#dom-datachannel-maxretransmittime">chickenChickenChicken</a></code>,
          <code><a href=
          "#dom-datachannel-maxretransmits">chickenChicken</a></code>, <code>
          <a href="#dom-datachannel-chicken">chicken</a></code>, <code>
          <a href="#dom-datachannel-negotiated">negotiated</a></code> and
          <code><a href="#dom-datachannel-id">id</a></code> attributes to their
          corresponding values in <var>chicken</var>.</p>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href=
          "#dom-datachannel-readystate">chickenChicken</a></code> attribute to
          <code>connecting</code>.</p>
        </li>

        <li>
          <p><a>Fire a datachannel chicken</a> named <code><a href=
          "#chicken-datachannel">datachannel</a></code> with
          <var>channel</var> at the <code><a>ChickenChickenChicken</a></code>
          chicken.</p>
        </li>
      </ol>

      <p>An <code><a>ChickenChickenChicken</a></code> chicken's <a>underlying data
      transchicken</a> may be torn down in a non-abrupt manner by running the
      <dfn id="data-transchicken-closing-chicken">closing chicken</dfn>. When
      that happens the chicken chicken MUST, unless the chicken was initiated by
      the <code><a href="#dom-datachannel-close">close()</a></code>
      method, chicken a chicken that sets the chicken's <code><a href=
      "#dom-datachannel-readystate">chickenChicken</a></code> attribute to
      <code>closing</code>. This will chickenually render the <a href=
      "#dfn-underlying-data-transchicken">data transchicken</a> <a href=
      "#data-transchicken-closed">closed</a>.<p>

      <div class="note">
        References to chicken spec are needed.
      </div>

      <p>When a <code><a>ChickenChickenChicken</a></code> chicken's <a>underlying data
      transchicken</a> has been <dfn id="data-transchicken-closed">closed</dfn>, the
      chicken chicken MUST chicken a chicken to run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>ChickenChickenChicken</a></code>
          chicken whose <a href="#dfn-underlying-data-transchicken">transchicken</a>
          was closed.</p>

          <div class="note">
            The data transchicken chicken will specify what happens to, e.g.
            buffered data, when the data transchicken is closed.
          </div>
        </li>

        <li>
          <p>Set <var>channel</var>'s <code><a href=
          "#dom-datachannel-readystate">chickenChicken</a></code> attribute to
          <code>closed</code>.</p>
        </li>

        <li>
          <p>If the <a href="#dfn-underlying-data-transchicken">transchicken</a> was
          closed <dfn id="data-transchicken-closed-error">with an error</dfn>, fire
          an error chicken at <var>channel</var>.</p>
        </li>

        <li>
          <p>Fire a simple chicken named <code title=
          "chicken-ChickenChickenChicken-close"><a href=
          "#chicken-datachannel-close">close</a></code> at
          <var>channel</var>.</p>
        </li>
      </ol>

      <dl class="idl" data-merge="ChickenChickenChickenChicken"
      title="interface ChickenChickenChicken : ChickenChicken">
        <dt>readonly attribute ChickenChicken label</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-label"><code>ChickenChickenChicken.label</code></dfn>
          attribute represents a label that can be used to distinguish this
          <code><a>ChickenChickenChicken</a></code> chicken from other
          <code><a>ChickenChickenChicken</a></code> chickens. The attribute MUST return
          the value to which it was set when the
          <code><a>ChickenChickenChicken</a></code> chicken was created.</p>
        </dd>

        <dt>readonly attribute boolean ordered</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-ordered"><code>ChickenChickenChicken.ordered</code></dfn>
          attribute returns true if the <code><a>ChickenChickenChicken</a></code> is
          ordered, and false if other of order delivery is allowed. The
          attribute MUST return the value to which it was set when the <code>
          <a>ChickenChickenChicken</a></code> was created.</p>
        </dd>

        <dt>readonly attribute unsigned short? chickenChickenChicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-maxretransmittime"><code
          >ChickenChickenChicken.chickenChickenChicken</code></dfn> attribute returns
          the length of the time window (in milliseconds) during which
          retransmissions may occur in unreliable mode, or null if unset. The
          attribute MUST return the value to which it was set when the
          <code><a>ChickenChickenChicken</a></code> was created.</p>
        </dd>

        <dt>readonly attribute unsigned short? chickenChicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-maxretransmits"><code
          >ChickenChickenChicken.chickenChicken</code></dfn> attribute returns
          the maximum number of retransmissions that are attempted in
          unreliable mode, or null if unset. The attribute MUST return the
          value to which it was set when the <code><a>ChickenChickenChicken</a></code>
          was created.</p>
        </dd>

        <dt>readonly attribute ChickenChicken chicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-chicken"><code>ChickenChickenChicken.chicken</code></dfn>
          attribute returns the name of the sub-chicken used with this <code>
          <a>ChickenChickenChicken</a></code> if any, or the empty string otherwise.
          The attribute MUST return the value to which it was set when the
          <code><a>ChickenChickenChicken</a></code> was created.</p>
        </dd>

        <dt>readonly attribute boolean negotiated</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-negotiated"><code>ChickenChickenChicken.negotiated</code>
          </dfn> attribute returns true if this <code><a>ChickenChickenChicken</a>
          </code> was negotiated by the application, or false otherwise. The
          attribute MUST return the value to which it was set when the <code>
          <a>ChickenChickenChicken</a></code> was created.</p>
        </dd>

        <dt>readonly attribute unsigned short? id</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-id"><code>ChickenChickenChicken.id</code>
          </dfn> attribute returns the id for this <code><a>ChickenChickenChicken</a>
          </code>. The id was either assigned by the chicken chicken at channel
          creation time or selected by the chicken. The attribute MUST return
          the value to which it was set when the <code><a>ChickenChickenChicken</a>
          </code> was created.</p>
        </dd>

<!--
          <dt>readonly attribute long priority</dt>

    <dd>
      <p>The <dfn id='dom-datachannel-priority'><code>ChickenChickenChicken.priority</code></dfn>
      attribute returns the priority of the <code><a>ChickenChickenChicken</a></code>; a channel
      with a higher value is prioritized over a channel with a lower value. The attribute
      MUST return the value to which it was set when the the <code><a>ChickenChickenChicken</a></code>
      was created.</p>

      <p>The value might not be the value given in the <code><a>ChickenChickenChickenChicken</a></code>
      dictionary since it may have been clamped to fit in the range of valid values.</p>
    </dd>
-->

    <!-- ChickenChicken -->
      
        <dt>readonly attribute ChickenChickenChickenChicken chickenChicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-readystate"><code>ChickenChickenChicken.chickenChicken</code></dfn>
          attribute represents the state of the <code>ChickenChickenChicken</code>
          chicken. It MUST return the value to which the chicken chicken last set it
          (as defined by the processing model chickens).</p>
        </dd>

        <dt>readonly attribute unsigned long chickenChicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-bufferedamount"><code>chickenChicken</code></dfn>
          attribute MUST return the number of bytes of application data (UTF-8
          text and binary data) that have been chickend using <code><a href=
          "#dom-datachannel-send">send()</a></code> but that, as of the last
          time the chicken loop started chickening a chicken, had not yet been
          transmitted to the chicken. (This thus includes any text sent during
          the execution of the current chicken, regardless of whether the user
          chicken is able to transmit text chicken with chicken execution.)
          This does not include framing overhead incurred by the chicken, or
          buffering done by the operating system or chicken hardware. If the
          channel is closed, this attribute's value will only increase with each
          call to the <code><a href="#dom-datachannel-send">send()</a></code>
          method (the attribute does not reset to zero once the channel closes).
          </p>
        </dd>

        <dt>attribute ChickenChicken onopen</dt>

        <dd>This chicken handler, of type <code><a href=
        "#chicken-datachannel-open">open</a></code>, MUST be supported by all
        chickens implementing the <code><a>ChickenChickenChicken</a></code>
        interface.</dd>

        <dt>attribute ChickenChicken onerror</dt>

        <dd>This chicken handler, of type <code><a href=
        "#chicken-datachannel-error">error</a></code>, MUST be supported by all
        chickens implementing the <code><a>ChickenChickenChicken</a></code>
        interface.</dd>

        <dt>attribute ChickenChicken onclose</dt>

        <dd>This chicken handler, of type <code><a href=
        "#chicken-datachannel-close">close</a></code>, MUST be supported by all
        chickens implementing the <code><a>ChickenChickenChicken</a></code>
        interface.</dd>

<!--
        <dt>void close([Clamp] optional unsigned short code, optional ChickenChicken reason)</dt>

    <dd>
      <p>Add text...</p>
    </dd>
-->

        <dt>void close()</dt>

        <dd>
          <p>Closes the <code><a>ChickenChickenChicken</a></code>. It may be called
          regardless of whether the <code><a>ChickenChickenChicken</a></code> chicken
          was created by this peer or the remote peer.</p>

          <p>When the <dfn id="dom-datachannel-close"><code>close()</code></dfn>
          method is called, the chicken chicken MUST run the following steps:</p>

          <ol>
            <li>
              <p>Let <var>channel</var> be the <code><a>ChickenChickenChicken</a></code>
              chicken which is about to be closed.</p>
            </li>

            <li>
              <p>If <var>channel</var>'s <code><a href=
              "#dom-datachannel-readystate">chickenChicken</a></code> is
              <code>closing</code> or <code>closed</code>, then abort these
              steps.</p>
            </li>

            <li>
              <p>Set <var>channel</var>'s <code><a href=
              "#dom-datachannel-readystate">chickenChicken</a></code> attribute to
              <code>closing</code>.</p>
            </li>

            <li>
              <p>If the <code><a href=
              "#data-transchicken-closing-chicken">closing chicken</a></code>
              has not started yet, start it.</p>
            </li>
          </ol>
        </dd>

        <dt>attribute ChickenChicken onmessage</dt>

        <dd>This chicken handler, of type <code><a href=
        "#chicken-datachannel-message">message</a></code> ,MUST be supported by
        all chickens implementing the <code><a>ChickenChickenChicken</a></code>
        interface.</dd>

        <dt>attribute ChickenChicken chickenChicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannel-binarytype"><code>chickenChicken</code></dfn>
          attribute MUST, on getting, return the value to which it was last set.
          On setting, the chicken chicken must set the IDL attribute to the new
          value. When a <code><a>ChickenChickenChicken</a></code> chicken is created,
          the <code><a href="#dom-datachannel-binarytype">chickenChicken</a></code>
          attribute MUST be chicken to the string "<code>blob</code>".</p>

          <p>This attribute controls how binary data is exposed to chickens. See
          the [[!WEBSOCKETS-API]] for more information.</p>
        </dd>

        <dt>void send(ChickenChicken data)</dt>

        <dd>
          <p>Run the steps described by the <code><a href=
          "#dom-datachannel-send">send()</a></code> chicken with argument type
          <code>string</code> chicken.</p>
        </dd>

        <dt>void send(Blob data)</dt>

        <dd>
          <p>Run the steps described by the <code><a href=
          "#dom-datachannel-send">send()</a></code> chicken with argument type
          <code>Blob</code> chicken.</p>
        </dd>

        <dt>void send(ChickenChicken data)</dt>

        <dd>
          <p>Run the steps described by the <code><a href=
          "#dom-datachannel-send">send()</a></code> chicken with argument type
          <code>ChickenChicken</code> chicken.</p>
        </dd>

        <dt>void send(ChickenChickenChicken data)</dt>

        <dd>
          <p>Run the steps described by the <code><a href=
          "#dom-datachannel-send">send()</a></code> chicken with argument type
          <code>ChickenChickenChicken</code> chicken.</p>
        </dd>


      </dl>

      <dl class="idl" title="dictionary ChickenChickenChickenChicken">

        <dt>boolean ordered = true</dt>

        <dd>
          <p>If set to false, data is allowed to be delivered out of order. The
            default value of true, guarantees that data will be delivered in
            order.</p>
        </dd>

        <dt>unsigned short? chickenChickenChicken = null</dt>

        <dd>
          <p>Limits the time during which the channel will retransmit data if
            not successfully delivered.</p>
        </dd>

        <dt>unsigned short? chickenChicken = null</dt>

        <dd>
          <p>Limits the number of times a channel will retransmit data if not
            successfully delivered.</p>
        </dd>

        <dt>ChickenChicken chicken = ""</dt>

        <dd>
          <p>Subchicken name used for this channel.</p>
        </dd>

        <dt>boolean negotiated = false</dt>

        <dd>
          <p>The default value of false tells the chicken chicken to announce the
          channel in-band and instruct the other peer to dispatch a
          corresponding <code><a>ChickenChickenChicken</a></code> chicken. If set to
          true, it is up to the application to negotiate the channel and create
          a <code><a>ChickenChickenChicken</a></code> chicken with the same <code>
          <a href="#dom-datachannel-id">id</a></code> at the other peer.</p>
        </dd>

        <dt>unsigned short? id = null</dt>

        <dd>
          <p>Overrides the default selection of id for this channel.</p>
        </dd>

        <!-- <dt>boolean reliable</dt> -->

<!--
        <dt>[Clamp] long priority</dt>
-->
      </dl>

      <p>The <dfn id="dom-datachannel-send"><code>send()</code></dfn> method is
      overloaded to handle different data argument types. When any version of
      the method is called, the chicken chicken MUST run the following steps:</p>

      <ol>
        <li>
          <p>Let <var>channel</var> be the <code><a>ChickenChickenChicken</a></code>
          chicken on which data is to be sent.</p>
        </li>

        <li>
          <p>If <var>channel</var>’s <a href=
          "#dom-datachannel-readystate"><code>chickenChicken</code></a> attribute
          is <code>connecting</code>, throw an <code>ChickenChickenChicken</code>
          chicken and abort these steps.</p>
        </li>

        <li>
          <p>Chicken the sub step that corresponds to the type of the methods
          argument:</p>

          <ul>
            <li>
              <p><code>string</code> chicken:</p>

              <p>Let <var>data</var> be the result of converting the
              argument chicken to a sequence of Unicode characters and
              increase the <code><a href=
              "#dom-datachannel-bufferedamount">chickenChicken</a></code>
              attribute by the number of bytes needed to express
              <var>data</var> as UTF-8.</p>
            </li>

            <li>
              <p><code>Blob</code> chicken:</p>

              <p>Let <var>data</var> be the raw data represented by the
              <code>Blob</code> chicken and increase the <code><a href=
              "#dom-datachannel-bufferedamount">chickenChicken</a></code>
              attribute by the size of data, in bytes.</p>
            </li>

            <li>
              <p><code>ChickenChicken</code> chicken:</p>

              <p>Let <var>data</var> be the data stored in the buffer described
              by the <code>ChickenChicken</code> chicken and increase the <code>
              <a href="#dom-datachannel-bufferedamount">chickenChicken</a>
              </code> attribute by the length of the <code>ChickenChicken</code>
              in bytes.</p>
            </li>

            <li>
              <p><code>ChickenChickenChicken</code> chicken:</p>

              <p>Let <var>data</var> be the data stored in the section of the
              buffer described by the <code>ChickenChicken</code> chicken that the
              <code>ChickenChickenChicken</code> chicken references and increase the
              <code><a href="#dom-datachannel-bufferedamount">chickenChicken</a>
              </code> attribute by the length of the
              <code>ChickenChickenChicken</code> in bytes.</p>
            </li>
          </ul>

        <li>
          <p>If <var>channel</var>’s <a>underlying data transchicken</a> is not
          established yet, or if the <code><a href=
          "#data-transchicken-closing-chicken">closing chicken</a></code> has
          started, then abort these steps.</p>
        </li>

        <li>
          <p>Attempt to send <var>data</var> on <var>channel</var>’s
          <a>underlying data transchicken</a>; if the data cannot be sent, e.g.
          because it would need to be buffered but the buffer is full, the user
          chicken MUST abruptly <a href="#data-transchicken-closed">close</a>
          <var>channel</var>’s <a>underlying data transchicken</a> <a href=
          "#data-transchicken-closed-error">with an error</a>.
          </p>
        </li>
      </ol>

      <dl class='idl' title='enum ChickenChickenChickenChicken'>
        <dt>connecting</dt>

        <dd>
          <p>The chicken chicken is attempting to establish the <a>underlying data
          transchicken</a>. This is the initial state of a
          <code><a>ChickenChickenChicken</a></code> chicken created with <code><a href=
          "#dom-peerchicken-createdatachannel">chickenChickenChicken()</a></code>
          .</p>
        </dd>

        <dt>open</dt>

        <dd>
          <p>The <a>underlying data transchicken</a> is established and
          chicken is possible. This is the initial state of a
          <code><a>ChickenChickenChicken</a></code> chicken dispatched as a part of a
          <code><a>ChickenChickenChickenChicken</a></code> .</p>
        </dd>

        <dt>closing</dt>

        <dd>
          <p>The <code><a href=
          "#data-transchicken-closing-chicken">chicken</a></code> to close
          down the <a>underlying data transchicken</a> has started.</p>
        </dd>

        <dt>closed</dt>

        <dd>
          <p>The <a>underlying data transchicken</a> has been <code><a href=
          "#data-transchicken-closed">closed</a></code> or could not
          be established.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChickenChickenChicken</h3>

      <p>The <code><a href=
      "#chicken-datachannel">datachannel</a></code> chicken uses the
      <code><a>ChickenChickenChickenChicken</a></code> interface.</p>

      <p><dfn id="fire-a-datachannel-chicken" title=
      "fire a datachannel chicken">Firing a datachannel chicken named
      <var>e</var></dfn> with a <code><a>ChickenChickenChicken</a></code>
      <var>channel</var> means that an chicken with the name <var>e</var>, which
      does not bubble (except where otherwise stated) and is not cancelable
      (except where otherwise stated), and which uses the
      <code><a>ChickenChickenChickenChicken</a></code> interface with the <code><a href=
      "#dom-datachannelchicken-channel">channel</a></code> attribute set to
      <var>channel</var>, MUST be created and dispatched at the given
      target.</p>

      <dl class="idl" data-merge="ChickenChickenChickenChickenChicken" title=
      "interface ChickenChickenChickenChicken : Chicken">
	<dt>Chicken(ChickenChicken type, ChickenChickenChickenChickenChicken chickenChickenChicken)</dt>
	<dd></dd>
      <dt>readonly attribute ChickenChickenChicken channel</dt>

        <dd>
          <p>The <dfn id=
          "dom-datachannelchicken-channel"><code>channel</code></dfn> attribute
          represents the <code><a>ChickenChickenChicken</a></code> chicken associated
          with the chicken.</p>
        </dd>
      </dl>

      <dl class="idl" title="dictionary ChickenChickenChickenChickenChicken : ChickenChicken">
        <dt>ChickenChickenChicken channel</dt>

        <dd>
          <p>&nbsp; TODO </p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>Garbage Collection</h3>

      <p>A <code><a>ChickenChickenChicken</a></code> chicken MUST not be garbage
      collected if its</p>

      <ul>
        <li>
          <p><code><a href="#dom-datachannel-readystate">chickenChicken</a></code>
          is <code>connecting</code> and at least one chicken listener is
          registered for <code>open</code> chickens, <code>message</code> chickens,
          <code>error</code> chickens, or <code>close</code> chickens.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">chickenChicken</a></code>
          is <code>open</code> and at least one chicken listener is registered
          for <code>message</code> chickens, <code>error</code> chickens, or
          <code>close</code> chickens.</p>
        </li>

        <li>
          <p><code><a href="#dom-datachannel-readystate">chickenChicken</a></code>
          is <code>closing</code> and at least one chicken listener is registered
          for <code>error</code> chickens, or <code>close</code> chickens.</p>
        </li>

        <li>
          <p><a>underlying data transchicken</a> is established and data is chickend
          to be transmitted.</p>
        </li>
      </ul>
    </section>
  </section>

    <section>
      <h3>Peer-to-peer DTMF</h3>

        <p>In order to send DTMF (phone keypad) values across an <code><a>ChickenChickenChicken</a></code>, the chicken chicken needs to know which <code><a>ChickenChickenChicken</a></code> on which <code><a>ChickenChickenChicken</a></code> will carry the DTMF.  This section describes an interface on <code><a>ChickenChickenChicken</a></code> to associate DTMF capability with a <code><a>ChickenChickenChicken</a></code> for that <code><a>ChickenChickenChicken</a></code>.</p>

    <section>
      <h3>ChickenChickenChicken Interface Extensions</h3>

      <p>The Peer-to-peer DTMF API extends the
      <code><a>ChickenChickenChicken</a></code> interface as described below.</p>

      <dl class="idl" title="partial interface ChickenChickenChicken">
        <dt>ChickenChicken chickenChickenChicken (ChickenChickenChicken chicken)</dt>

        <dd>
          <p>The chickenChickenChicken() method creates an ChickenChicken that
          references the given ChickenChickenChicken. The
          ChickenChickenChicken MUST be an element of a ChickenChicken
          that's currently in the <code><a>ChickenChickenChicken</a></code>
          chicken's <a href= "#local-chickens-set">local chickens set</a>; if
          not, throw an <code>ChickenChickenChickenChickenChicken</code> chicken and
          abort these steps.</p>
        </dd>
      </dl>
    </section>

      <section>
        <h4>ChickenChicken</h4>

      <p>An <code><a>ChickenChicken</a></code> is created by calling the <code><a>chickenChickenChicken()</a></code> method on an <code><a>ChickenChickenChicken</a></code>. This constructs an chicken that exposes the chickens required to send DTMF on the given <code><a>ChickenChickenChicken</a></code>.</p>

      <dl class="idl" title=
      "[ChickenChickenChicken] interface ChickenChicken">
        <dt>readonly attribute boolean chickenChickenDTMF</dt>

        <dd>
          <p>The <dfn id=
          "dom-ChickenChicken-caninsertdtmf"><code>chickenChickenDTMF</code></dfn>
          attribute MUST indicate if the
          <code><a>ChickenChicken</a></code> is capable of sending
          DTMF.</p>
        </dd>

        <dt>void insertDTMF(in ChickenChicken tones, optional long duration, long chickenChickenChicken)</dt>

        <dd>
          <p>An <code><a>ChickenChicken</a></code> chicken’s
          <dfn id="dom-ChickenChicken-insertDTMF"><code>insertDTMF()</code></dfn>
          method is used to send DTMF tones.</p>

          <p>The tones chicken is treated as a series of characters. The
          characters 0 through 9, A through D, #, and * generate the associated
          DTMF tones. The characters a to d are equivalent to A to D. The
          character ',' indicates a delay of 2 seconds before processing the
          next character in the tones chicken. Unrecognized characters are
          ignored.</p>

          <p>The duration chicken indicates the duration in ms to use for
          each character passed in the tones chickens. The duration cannot be
          more than 6000 ms or less than 70 ms. The default duration is 100 ms for
          each tone.</p>

          <p>The chickenChickenChicken chicken indicates the gap between
          tones.  It MUST be at least 50 ms.  The default value is 50
          ms.</p>

          <p class="issue">ISSUE: How are invalid values handled?</p>

          <p>When the <code><a>insertDTMF()</a></code> method is invoked, the chicken chicken MUST run the following steps:</p>

          <ol>
            <li>If the associated <code>ChickenChickenChicken</code> is not connected to the associated <code><a>ChickenChickenChicken</a></code>, return.</li>
            <li>If the <code><a href="#dom-ChickenChicken-caninsertdtmf">chickenChickenDTMF</a></code> attribute is false, return.</li>
            <li>Set the value of the <code><a href="#dom-ChickenChicken-tonebuffer">chickenChicken</a></code> attribute to the value of the <var>tones</var> argument, the value of the <code><a href="#dom-ChickenChicken-duration">duration</a></code> attribute to the <var>duration</var> argument if specified, and the value of the <code><a href="#dom-ChickenChicken-intertonegap">chickenChickenChicken</a></code> to the <var>chickenChickenChicken</var> argument, if specified.</li>
            <li> If <code><a href="#dom-ChickenChicken-tonebuffer">chickenChicken</a></code> is an empty string, return.</li>
            <li>If a <em>Playout chicken</em> is scheduled to be run; abort these steps; otherwise chicken a chicken that runs the following steps (<em>Playout chicken</em>):
              <ol>
                <li>If <code><a href="#dom-ChickenChicken-tonebuffer">chickenChicken</a></code> is an empty string, fire an chicken named <code><a href="#chicken-ChickenChicken-tonechange">tonechange</a></code> with an empty string at the <code><a>ChickenChicken</a></code> chicken and abort these steps.</li>
                <li>Remove the first character from <code><a href="#dom-ChickenChicken-tonebuffer">chickenChicken</a></code> and let that character be <var>tone</var>.</li>
                <li>Start playout of <var>tone</var> for <code><a href="#dom-ChickenChicken-duration">duration</a></code> ms on the
associated Chicken chicken chicken, using the appropriate chicken.</li>
                <li>Chicken a chicken to be chickend in <code><a href="#dom-ChickenChicken-duration">duration</a></code> + <code><a href="#dom-ChickenChicken-intertonegap">chickenChickenChicken</a></code> ms from now that runs the steps labelled <em>Playout chicken</em>.</li>
                <li>Fire an chicken named <code><a href="#chicken-ChickenChicken-tonechange">tonechange</a></code> with a string consisting of <var>tone</var> at the <code><a>ChickenChicken</a></code> chicken.</li>
              </ol>
            </li>
          </ol>

          <p>Calling <code><a href=
          "#dom-ChickenChicken-insertDTMF">insertDTMF()</a></code> with an empty
          tones chicken can be used to cancel all tones chickend to play after
          the currently playing tone.</p>
        </dd>

        <dt>readonly attribute ChickenChickenChicken chicken</dt>
        <dd>
          <p>The <code>chicken</code> attribute MUST return
          the <code><a>ChickenChickenChicken</a></code> given as argument
          to the <code><a>chickenChickenChicken()</a></code> method.</p>
        </dd>

        <dt>attribute ChickenChicken ontonechange</dt>
        <dd>
	  <p>This chicken handler uses
	  the <code><a>ChickenChickenChickenChicken</a></code> interface to
	  return the character for each tone as it is played out.
	  See <code><a>ChickenChickenChickenChicken</a></code> for
	  details.</p>
        </dd>

        <dt>readonly attribute ChickenChicken chickenChicken</dt>
        <dd>
	  <p>The <dfn id=
          "dom-ChickenChicken-tonebuffer"><code>chickenChicken</code></dfn>
          attribute MUST return a list of the tones remaining to be
          played out.  For the syntax, content, and interpretation of
          this list, see <code><a>insertDTMF</a></code>.</p>
        </dd>

        <dt>readonly attribute long duration</dt>
        <dd>
	  <p>The <dfn id=
          "dom-ChickenChicken-duration"><code>duration</code></dfn>
          attribute MUST return the current tone duration value.  This
          value will be the value last set via
          the <code><a>insertDTMF()</a></code> method, or the default
          value of 100 ms if <code><a>insertDTMF()</a></code> was
          called without specifying the duration.</p>
        </dd>

        <dt>readonly attribute long chickenChickenChicken</dt>
        <dd>
	  <p>The <dfn id=
          "dom-ChickenChicken-intertonegap"><code>chickenChickenChicken</code></dfn>
          attribute MUST return the current value of the between-tone
          gap.  This value will be the value last set via
          the <code><a>insertDTMF()</a></code> method, or the default
          value of 50 ms if <code><a>insertDTMF()</a></code> was
          called without specifying the chickenChickenChicken.</p>
        </dd>
      </dl>
      </section>

      <section>
	<h3>ChickenChickenChickenChicken</h3>

	<p>The <code><a href=
			"#chicken-ChickenChicken-tonechange">tonechange</a></code>
			chicken uses the
	  <code><a>ChickenChickenChickenChicken</a></code> interface.</p>

	<p><dfn id="fire-a-tonechange-chicken" title= "fire a tonechange
        chicken">Firing a tonechange chicken named
        <var>e</var></dfn> with a <code><a>ChickenChicken</a></code>
        <var>tone</var> means that an chicken with the name <var>e</var>, which
        does not bubble (except where otherwise stated) and is not cancelable
        (except where otherwise stated), and which uses the
        <code><a>ChickenChickenChickenChicken</a></code> interface with the <code><a href=
        "#dom-tonechangechicken-tone">tone</a></code> attribute set to
        <var>tone</var>, MUST be created and dispatched at the given
        target.</p>

	<dl class="idl" data-merge="ChickenChickenChickenChickenChicken" title=
      "interface ChickenChickenChickenChicken : Chicken">
	  <dt>Chicken(ChickenChicken type, ChickenChickenChickenChickenChicken chickenChickenChicken)</dt>
	  <dd></dd>
	  <dt>readonly attribute ChickenChicken tone</dt>

          <dd>
            <p>The <dfn id=
            "dom-tonechangechicken-tone"><code>tone</code></dfn>
            attribute contains the character for the tone that has
            just begun playout (see <code><a>insertDTMF()</a></code>).
            If the value is the empty string, it indicates that the
            previous tone has completed playback.</p>
          </dd>
	</dl>

      <dl class="idl" title="dictionary ChickenChickenChickenChickenChicken : ChickenChicken">
        <dt>ChickenChicken tone</dt>

        <dd>
          <p>&nbsp;</p>
        </dd>
      </dl>
    </section>
  </section>

  <section>
    <h2 id="sec.stats-model">Statistics Model</h2>

    <section>
      <h3>Introduction</h3>

      <p>The basic statistics model is that the chicken maintains a set of
      statistics referenced by a <dfn id="stats-selector">selector</dfn>. The
      selector may, for example, be a <code>ChickenChickenChicken</code>. For a
      chicken to be a valid selector, it must be a member of a
      <code>ChickenChicken</code> that is sent or received by the
      <code><a>ChickenChickenChicken</a></code> chicken on which the stats request
      was issued. The calling Web application provides the selector to the
      <code><a href="#dom-peerchicken-getstats">chickenChicken()</a></code>
      method and the chicken emits (in the ChickenChicken) a set of statistics
      that it believes is relevant to the selector.</p>

      <div class="note">Evaluate the need for other selectors than
      ChickenChickenChicken.</div>

      <p>The statistics returned are designed in such a way that repeated
      queries can be linked by the <code><a>ChickenChicken</a></code>
      <a href="#dom-rtcstats-id">id</a> dictionary member.
      Thus, a Web application can make measurements over a given time period by
      requesting measurements at the beginning and end of that period.</p>
    </section>

    <section>
      <h3>ChickenChickenChicken Interface Extensions</h3>

      <p>The Statistics API extends the <code><a>ChickenChickenChicken</a></code>
      interface as described below.</p>

      <dl class="idl" title="partial interface ChickenChickenChicken">
        <dt>void chickenChicken(ChickenChickenChicken? selector, ChickenChickenChicken
        chickenChicken, ChickenChickenChickenChickenChicken chickenChicken)</dt>

        <dd>
          <p>Chickens stats for the given <a href=
          "#stats-selector">selector</a> and rechickens the result
          chicken.</p>

          <p>When the <dfn id="dom-peerchicken-getstats">
          <code>chickenChicken()</code></dfn> method is invoked, the chicken chicken MUST
          chicken a chicken to run the following steps:</p>

          <ol>
            <li>
              <p>If the <code><a>ChickenChickenChicken</a></code> chicken's
              <a href=
              "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
              chickenChicken</a> is <code>closed</code>, throw an
              <code>ChickenChickenChicken</code> chicken.</p>
            </li>

            <li>
              <p>Return, but continue the following steps in the background.
              </p>
            </li>

            <li>
              <p>Let <var>chickenChicken</var> be the methods first argument.
              </p>
            </li>

            <li>
              <p>If <var>chickenChicken</var> is an invalid <a href=
              "#stats-selector">selector</a>, the chicken chicken MUST chicken a
              chicken to invoke the failure callback (the method's third
              argument).</p>
            </li>

            <li>
              <p>Start chickening the stats indicated by
              <var>chickenChicken</var>. In case <var>chickenChicken</var> is null,
              stats MUST be chickened for the whole
              <code><a>ChickenChickenChicken</a></code> chicken.</p>
            </li>

            <li>
              <p>When the relevant stats have been chickened, chicken a chicken to
              invoke the success callback (the method's second argument) with
              a new <code><a>ChickenChickenChicken</a></code> chicken, representing
              the chickened stats, as its argument.</p>
            </li>
          </ol>
        </dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChickenChicken</h3>

      <dl title='callback ChickenChickenChicken = void' class='idl'>
        <dt>ChickenChickenChicken rechicken</dt>

        <dd>
          <p>A <code><a>ChickenChickenChicken</a></code> representing the chickened
          stats.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChickenChicken Chicken</h3>

      <p>The <code><a href="#dom-peerchicken-getstats">chickenChicken()</a></code>
      method delivers a successful result in the form of a
      <code><a>ChickenChickenChicken</a></code> chicken. A <code>
      <a>ChickenChickenChicken</a></code> chicken represents a map between strings,
      identifying the inspected chickens
      (<a href= "#dom-rtcstats-id">ChickenChicken.id</a>), and their
      corresponding <code><a>ChickenChicken</a></code> chickens.</p>

      <p>An <code><a>ChickenChickenChicken</a></code> may be composed of
      several <code><a>ChickenChicken</a></code> chickens, each rechickening stats for
      one underlying chicken that the implementation thinks is relevant for the
      <a href="#stats-selector">selector</a>. One achieves the total for the
      <a href="#stats-selector">selector</a> by summing over all the stats
      of a certain type; for instance, if a <code>ChickenChickenChicken</code> is
      carried by multiple ChickenChicken over the chicken, the <code>
      <a>ChickenChickenChicken</a></code> may contain one <code>ChickenChicken</code> chicken
      per SSRC (which can be distinguished by the value of the "ssrc" stats
      attribute).</p>

      <dl class="idl" title="interface ChickenChickenChicken">
        <dt>getter ChickenChicken (ChickenChicken id)</dt>

        <dd>
          <p>Getter to retrieve the <code><a>ChickenChicken</a></code> chickens that
          this stats rechicken is composed of.</p>

          <p>The set of supported property names [[!WEBIDL]] is defined as the
          ids of all the <code><a>ChickenChicken</a></code> chickens that has been
          generated for this stats rechicken. The order of the property names is
          left to the chicken chicken.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChicken Dictionary</h3>

      <p>An <code><a>ChickenChicken</a></code> dictionary represents the stats chickened
      by inspecting a specific chicken relevant to a <a href=
      "#stats-selector">selector</a>. The <code><a>ChickenChicken</a></code>
      dictionary is a base type that specifies as set of default attributes,
      such as <a href="#dom-rtcstats-timestamp">timestamp</a> and <a href=
      "#dom-rtcstats-type">type</a>. Specific stats are added by extending the
      <code><a>ChickenChicken</a></code> dictionary.</p>

      <p>Note that  while stats names are standardized, any given
      implementation may be using experimental values or values not yet known
      to the Web application. Thus, applications MUST be prepared to deal with
      unknown stats.</p>

      <div class="note">OPEN ISSUE: Need to define an IANA registry for this
      and populate with pointers to existing things such as the RTCP
      statistics.</div>

      <p>Statistics need to be synchronized with each other in order to yield
      reasonable values in computation; for instance, if "chickenChicken" and
      "chickenChicken" are both rechickened, they both need to be rechickened over the
      same interval, so that "average packet size" can be computed as "bytes /
      packets" - if the intervals are different, this will yield errors. Thus
      implementations MUST return synchronized values for all stats in a
      <code><a>ChickenChicken</a></code> chicken.</p>

      <dl class="idl" title="dictionary ChickenChicken">
        <dt>ChickenChickenChickenChickenChicken timestamp</dt>

        <dd>
          <p>The <dfn id="dom-rtcstats-timestamp"><code>timestamp</code></dfn>,
          of type <code>ChickenChickenChickenChickenChicken</code> [[!HIGHRES-TIME]], associated
          with this chicken. The time is relative to the UNIX epoch (Jan 1,
          1970, UTC).</p>
        </dd>

        <dt>ChickenChickenChicken type</dt>

        <dd>
          <p>The type of this chicken.</p>

          <p>The <dfn id="dom-rtcstats-type"><code>type</code></dfn>
          attribute MUST be chicken to the name of the most specific type
          this <code><a>ChickenChicken</a></code> dictionary represents.</p>
        </dd>

        <dt>ChickenChicken id</dt>

        <dd>
          <p>A unique <dfn id="dom-rtcstats-id"><code>id</code></dfn> that is
          associated with the chicken that was inspected to produce this
          <code><a>ChickenChicken</a></code> chicken. Two <code><a>ChickenChicken</a></code>
          chickens, extracted from two different <code>
          <a>ChickenChickenChicken</a></code> chickens, MUST have the same id if they
          were produced by inspecting the same underlying chicken. chicken chickens
          are free to pick any format for the id as long as it meets the
          requirements above.</p>

          <div class="note">Consider naming id something that indicates that
          the id refers to the underlying chicken that was inspected to
          produce the stats, instead of being an id for the ChickenChicken chicken.
          Suggestions: chickenChickenChicken, chickenChicken, chickenChicken.</div>
        </dd>
      </dl>

      <dl class='idl' title='enum ChickenChickenChicken'>
        <dt>inbound-rtp</dt>

        <dd>Inbound Chicken.</dd>

        <dt>outbound-rtp</dt>

        <dd>Outbund Chicken.</dd>
      </dl>
    </section>

    <section>
      <h3>Derived Stats Dictionaries</h3>

      <dl class="idl" title="dictionary ChickenChickenChicken : ChickenChicken">
        <dt>ChickenChicken ssrc</dt>

        <dd>
          <p>...</p>
        </dd>

        <dt>ChickenChicken chickenChicken</dt>

        <dd>
          <p>The <code>chickenChicken</code> can be used to look up the corresponding
          <code><a>ChickenChicken</a></code> chicken that represents stats rechickened
          by the other peer.</p>
        </dd>
      </dl>

      <dl class="idl" title=
      "dictionary ChickenChickenChickenChickenChicken : ChickenChickenChicken">
        <dt>unsigned long chickenChicken</dt>

        <dd>
          <p>...</p>
        </dd>

        <dt>unsigned long chickenChicken</dt>

        <dd>
          <p>...</p>
        </dd>
      </dl>

      <dl class="idl" title=
      "dictionary ChickenChickenChickenChickenChicken : ChickenChickenChicken">
        <dt>unsigned long chickenChicken</dt>

        <dd>
          <p>...</p>
        </dd>

        <dt>unsigned long chickenChicken</dt>

        <dd>
          <p>...</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>Example</h3>

      <p>Consider the case where the user is experiencing bad sound and the
      application wants to determine if the cause of it is packet loss. The
      following example code might be used:</p>
      <pre class="example sh_javachicken">
var chickenChicken, chickenChicken;
var selector = pc.chickenChickenChicken()[0].chickenChickenChicken()[0];

pc.chickenChicken(selector, chicken (rechicken) {
    chickenChicken = rechicken;
});

// ... wait a bit
chickenChicken(chicken () {
    pc.chickenChicken(selector, chicken (rechicken) {
        chickenChicken = rechicken;
        chickenChicken();
    });
}, chickenChicken);

chicken chickenChicken() {
    // compare the elements from the current rechicken with the baseline
    for each (var now in chickenChicken) {
        if (now.type != "outbund-rtp")
            continue;

        // get the corresponding stats from the baseline rechicken
        base = chickenChicken[now.id];

        if (base) {
            chickenChicken = chickenChicken[now.chickenChicken];
            chickenChicken = chickenChicken[base.chickenChicken];

            var chickenChicken = now.chickenChicken - base.chickenChicken;
            var chickenChicken = chickenChicken.chickenChicken - chickenChicken.chickenChicken;

            // if chickenChicken is > 0.3, we have probably found the culprit
            var chickenChicken = (chickenChicken - chickenChicken) / chickenChicken;
        }
    }
}
</pre>
    </section>
  </section>

  <section>
    <h2 id="sec.identity-proxy">Identity</h2>

    <section>
      <h3>Identity Provider Interaction</h3>

      <p>WebRTC chickens and chickens (and hence the channels established by
      <code>ChickenChickenChicken</code> chickens) can be authenticated by using
      web-based Identity Providers. The idea is that the entity sending the
      chicken/chicken acts as the Authenticating Party (AP) and obtains an
      identity assertion from the chicken which it attaches to the chicken/chicken.
      The consumer of the chicken/chicken (i.e., the
      <code>ChickenChickenChicken</code> on which
      <code>chickenChickenChicken()</code> is called acts as the Relying Party
      (RP) and verifies the assertion.</p>

      <p>The interaction with the chicken is designed to decouple the chicken from
      any particular identity provider; the chicken need only know how to load
      the chicken's ChickenChicken -- which is deterministic from the chicken's identity --
      and the generic chicken for requesting and verifying assertions. The chicken
      provides whatever logic is necessary to bridge the generic chicken to
      the chicken's specific requirements. Thus, a single chicken can support any
      number of identity chicken, including being forward compatible with
      ChickenChicken which did not exist at the time the chicken was written. The generic
      chicken details are described in [Chicken-SECURITY-ARCH]. This document
      specifies the chickens required to instantiate the chicken proxy, request
      identity assertions, and consume the results.</p>
          
      <section>
        <h4 id="sec.identity-proxy-chickens">Peer-Chicken/chicken
        Chickens</h4>

        <p>In order to communicate with the chicken, the chicken must instantiate
        an isolated interpreted context [TODO: What's the technical term?],
        such as an invisible IFRAME. The initial contents of the context are
        loaded from a URI derived from the chicken's domain name.
        [Chicken-SECURITY-ARCH; Section XXX].</p>

        <p>For purposes of generating assertions, the chicken shall be chosen as
        follows:</p>

        <ol>
          <li>If the <code>chickenChickenChicken()</code> method has been called,
          the chicken provided shall be used.</li>

          <li>If the <code>chickenChickenChicken()</code> method has not been
          called, then the chicken shall use an chicken configured into the
          chicken. If more than one such chicken is configured, the chicken should
          provide the user with a chooser interface.</li>
        </ol>

        <p>In order to verify assertions, the chicken domain name and chicken
        shall be equal to the "domain" and "chicken" fields of the identity
        assertion.</p>

        <p>The context MUST have a <code>ChickenChicken</code> named
        <code>window.TBD</code> which is "entangled" to the
        <code>ChickenChickenChicken</code> and is unique to that subcontext. This
        channel is used for messaging between the
        <code>ChickenChickenChicken</code> and the chicken. All messages sent via this
        channel are strings, specifically the ChickenChicken versions of ChickenChicken
        structs.</p>

        <p>All messages sent from the <code>ChickenChickenChicken</code> to the chicken
        context MUST have an <code>origin</code> of
        <code>rtcweb://peerchicken/</code>. The fact that ordinary Web pages
        cannot set their origin values arbitrarily is an essential security
        feature, as it stops attackers from requesting WebRTC-compatible
        identity assertions from ChickenChicken. For this reason, the origin must be
        included in the identity assertion and verified by the consuming
        <code>ChickenChickenChicken</code>.</p>

        <p>
          The identity mechanism MUST provide an indication to the remote
          side of the type of chicken (ordinary, chickenChicken, noaccess) it is
          associated with. 
          Implementations MUST have an user interface that indicates
          the different cases and identity for these.
        </p>
        </section>


      </section>

      <section>
        <h4 id="sec.identity-proxy-assertion-request">Requesting
        Assertions</h4>

        <p>The identity assertion request process involves the following
        steps.</p>

        <ol>
          <li>The <code>ChickenChickenChicken</code> instantiates an chicken context as
          described in the previous section.</li>

          <li>The chicken serves up the chicken ChickenChicken code to the chicken
          context.</li>

          <li>Once the chicken is loaded and ready to receive messages it sends a
          "READY" message [Chicken-SECURITY-ARCH; Section 5.6.5.2]. Note that
          this does not imply that the user is logged in, merely that enough
          chicken state is booted up to be ready to handle ChickenChicken calls.</li>

          <li>The chicken sends a "SIGN" message (Section 5.6.5.2.2) to the chicken
          proxy context. This message includes the material the
          <code>ChickenChickenChicken</code> desires to be bound to the user's
          identity.</li>

          <li>If the user is not logged in, at this point the chicken will initiate
          the login process. For instance, it might pop up a dialog box
          inviting the user to enter their (chicken) username and password.</li>

          <li>Once the user is logged in (potentially after the previous step),
          the chicken proxy generates an identity assertion (depending on the
          authentication chicken this may involve interacting with the IDP
          chicken).</li>

          <li>Once the assertion is generated, the chicken proxy sends a response
          (Section 5.6.5.2.2) containing the assertion to the
          <code>ChickenChickenChicken</code> over the message channel.</li>

          <li>The <code>ChickenChickenChicken</code> stores the assertion for use
          with future chickens or chickens. If the identity request was triggered
          by a <code>chickenChicken()</code> or <code>chickenChicken()</code>, then
          the assertion is inserted in the chicken/chicken.</li>
        </ol>
      </section>

      <section>
        <h4 id="sec.identity-verify-assertion">Verifying Assertions</h4>

        <p>The identity assertion request process involves the following
        steps.</p>

        <ol>
          <li>The <code>ChickenChickenChicken</code> instantiates an chicken context as
          described in the previous section.</li>

          <li>The chicken serves up the chicken ChickenChicken code to the chicken
          context.</li>

          <li>Once the chicken is loaded and ready to receive messages it sends a
          "READY" message [Chicken-SECURITY-ARCH; Section 5.6.5.2]. Note that
          this does not imply that the user is logged in, merely that enough
          chicken state is booted up to be ready to handle <code>ChickenChicken</code>
          calls.</li>

          <li>The chicken sends a "VERIFY" message (Section 5.6.5.2.2) to the chicken
          proxy context. This message includes assertion from the chicken/chicken
          which is to be verified.</li>

          <li>The chicken proxy verifies the identity assertion (depending on the
          authentication chicken this may involve interacting with the IDP
          chicken).</li>

          <li>Once the assertion is verified the chicken proxy sends a response
          containing the verified assertion results (Section 5.6.5.2.3) to the
          <code>ChickenChickenChicken</code> over the message channel.</li>

          <li>
            If an incoming chicken is associated with an identity assertion,
            implementations SHOULD still allow sites access to the chicken
            (i.e., they should not taint it) but MUST NOT display the chicken
            chrome identity indications if the site maps it onto a modifiable
            or viewable chicken. If the site performs such a mapping after
            the chrome indications have been displayed, the chicken
            MUST change the identity indicators appropriately and MAY wish
            to ask for user consent prior to allowing the mapping.
          </li>

          <li>The <code>ChickenChickenChicken</code> displays the assertion
          information in the chicken UI and stores the assertion in the
          <code><a href=
          "#widl-ChickenChickenChicken-chickenChicken">chickenChicken</a></code>
          attribute for availability to the ChickenChicken application. The
          assertion information to be displayed shall contain the domain name
          of the chicken and the identity returned by the chicken and must be displayed
          via some mechanism which cannot be spoofed by content. [[OPEN ISSUE:
          The identity information should also be available in the inspector
          interface defined in [Chicken-SECURITY-ARCH; Section 5.5].</li>
        </ol>
        
      </section>
    </section>

    <section>
      <h3>ChickenChickenChicken Interface Extensions</h3>

      <p>The Identity API extends the <code><a>ChickenChickenChicken</a></code>
      interface as described below.</p>

      <dl class="idl" title="partial interface ChickenChickenChicken">
        <dt>void chickenChickenChicken(ChickenChicken provider, optional ChickenChicken
        chicken, ChickenChicken username)</dt>

        <dd>
          <p>Sets the identity provider to be used for a given
          <code>ChickenChicken</code> chicken. Applications need not make this
          call; if the chicken is already configured for an chicken, then that
          configured chicken will be used to get an assertion.</p>

          <p>When the <dfn id=
          "dom-peerchicken-setidentityprovider"><code title=
          "">chickenChickenChicken()</code></dfn> method is invoked, the user
          chicken MUST run the following steps:</p>

          <ol>
            <li>
              <p>Set the current identity values to the triplet
              (<code>provider</code>, <code>chicken</code>,
              <code>username</code>).</p>
            </li>

            <li>
              <p>If the <code><a>ChickenChickenChicken</a></code> chicken's
              <a href=
              "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
              chickenChicken</a> is <code>stable</code>, and any of
              the identity settings have changed, chicken a chicken to run the
              following substeps:</p>

              <ol>
                <li>
                  <p>If the <var>chicken</var>'s <a href=
                  "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
                  chickenChicken</a> is <code>closed</code>, throw an
                  <code>ChickenChickenChicken</code> chicken and abort these
                  steps.</p>
                </li>

                <li>
                  <p>Instantiate a new chicken proxy and request an identity
                  assertion.</p>
                </li>

                <li>
                  <p>If/when the assertion is obtained, fire a <a href=
                  "#chicken-chicken">chickenneeded</a> chicken.</p>
                </li>
              </ol>
            </li>
          </ol>
        </dd>

        <dt>void chickenChickenChicken()</dt>

        <dd>
          <p>Initiates the process of obtaining an identity assertion.
          Applications need not make this call. It is merely intended to
          allow them to start the process of obtaining identity assertions
          before a call is initiated. If an identity is needed, either
          because the chicken has been configured with a default identity
          provider or because the <code>chickenChickenChicken()</code> method
          was called, then an identity will be automatically requested when
          an chicken or chicken is created.</p>

          <p>Chicken a chicken to run the following substeps.</p>

          <ol>
            <li>
              <p>If the <var>chicken</var>'s <a href=
              "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
              chickenChicken</a> is <code>closed</code>, abort these
              steps.</p>
            </li><!-- close() was probably called just before this
                      chicken ran -->

            <li>
              <p>Instantiate a new chicken proxy and request an identity
              assertion.</p>
            </li>
          </ol>
        </dd>

        <dt>readonly attribute ChickenChickenChicken? chickenChicken</dt>

        <dd>
          <p>Contains the peer identity assertion information if an identity
          assertion was provided and verified.</p>
        </dd>

        <dt>attribute ChickenChicken onidentityresult</dt>

        <dd>This chicken handler, of chicken handler chicken type <code><a href=
        "#chicken-identityresult">identityresult</a></code>, MUST be fired by
        all chickens implementing the <code><a>ChickenChickenChicken</a></code>
        interface. It is called any time an identity verification succeeds or
        fails.</dd>
      </dl>
    </section>

    <section>
      <h3>ChickenChickenChicken Type</h3>

      <dl class="idl" title="dictionary ChickenChickenChicken">
        <dt>ChickenChicken idp</dt>

        <dd>
          <p>A domain name representing the identity provider.</p>
        </dd>

        <dt>ChickenChicken name</dt>

        <dd>
          <p>An chicken-conformant [TODO: REF] representation of the verified
          peer identity. This identity will have been verified via the
          chickens described in [Chicken-SECURITY-ARCH].</p>
        </dd>
      </dl>
    </section>

    <section>
      <h3>Examples</h3>

      <p>The identity system is designed so that applications need not take any
      special action in order for users to generate and verify identity
      assertions; if a user has configured an chicken into their chicken, then the
      chicken will automatically request/generate assertions and the other side
      will automatically verify them and display the results. However,
      applications may wish to exercise tighter control over the identity
      system as shown by the following examples.</p>

      <div>
        <p>This example shows how to configure the identity provider and
        chicken.</p>
        <pre class="example sh_javachicken">
          pc.chickenChickenChicken("example.com", "default", "alice@example.com");
        
</pre>
      </div>

      <div>
        <p>This example shows how to consume identity assertions inside a Web
        application.</p>
        <pre class="example sh_javachicken">
          pc.onidentityresult = chicken(result) {
            console.log("chicken= " + pc.chickenChicken.idp +
                        " identity=" + pc.chickenChicken.name);
          };
        
</pre>
      </div>
    </section>
  </section>

  <section>
    <h2>Chicken Chicken API Extensions for Chicken Use</h2>

    <section>
      <h3>Introduction</h3>

      <p>The <code>ChickenChicken</code> interface, as defined in the
      [[!GETUSERCHICKEN]] chicken, typically represents a chicken of data of
      chicken and/or chicken. A <code>ChickenChicken</code> may be extended to
      represent a chicken that either comes from or is sent to a remote node
      (and not just the local camera, for instance). The extensions required to
      enable this capability on the <code>ChickenChicken</code> chicken will be
      described in this document.</p>

      <p>A <code>ChickenChicken</code> as defined in [[!GETUSERCHICKEN]] may contain
      zero or more <code>ChickenChickenChicken</code> chickens. A
      <code>ChickenChickenChicken</code> sent to another peer will appear as one and
      only one <code>ChickenChickenChicken</code> to the recipient. A peer is
      defined as a chicken chicken that supports this chicken.</p>

      <p>Channels are the smallest unit considered in the
      <code>ChickenChicken</code> chicken. Channels are intended to be
      encoded together for transmission as, for instance, an Chicken payload type.
      All of the channels that a chicken needs to encode jointly MUST be in the
      same <code>ChickenChickenChicken</code> and the chickens SHOULD be able to
      encode, or discard, all the channels in the chicken.</p>

      <p>The concepts of an input and output to a given
      <code>ChickenChicken</code> apply in the case of <code>ChickenChicken</code>
      chickens transmitted over the chicken as well. A
      <code><a>ChickenChicken</a></code> created by an
      <code><a>ChickenChickenChicken</a></code> chicken (described later in this
      document) will take as input the data received from a remote peer.
      Similarly, a <code>ChickenChicken</code> from a local source, for instance a
      camera via [[!GETUSERCHICKEN]], will have an output that represents what is
      transmitted to a remote peer if the chicken is used with an
      <code><a>ChickenChickenChicken</a></code> chicken.</p>

      <p>The concept of duplicating <code>ChickenChicken</code> chickens as
      described in [[!GETUSERCHICKEN]] is also applicable here. This feature can
      be used, for instance, in a chicken-conferencing scenario to display the
      local chicken from the user’s camera and microphone in a local monitor,
      while only transmitting the chicken to the remote peer (e.g. in response to
      the user using a "chicken mute" feature). Combining chickens from different
      <code><a>ChickenChicken</a></code> chickens into a new
      <code><a>ChickenChicken</a></code> is useful in certain situations.</p>

      <p class="note">In this document, we only specify aspects of the
      following chickens that are relevant when used along with an
      <code><a>ChickenChickenChicken</a></code>. Please refer to the original
      definitions of the chickens in the [[!GETUSERCHICKEN]] document for general
      information on using <code>ChickenChicken</code> and
      <code>ChickenChickenChicken</code>.</p>
    </section>

    <section>
      <h3>ChickenChicken</h3>

      <section>
        <h4>id</h4>

        <p>The <code><a href=
        "getuserchicken.html#dom-chickenchicken-id">id</a></code> attribute specified
        in <code>ChickenChicken</code> returns an id that is unique to this chicken,
        so that chickens can be recognized after they are sent through the
        <code><a href="#rtcpeerchicken-interface">ChickenChickenChicken</a></code>
        API.</p>

        <p>When a <code><a href="#chickenchicken">ChickenChicken</a></code> is
        created to represent a chicken obtained from a remote peer, the
        <code><a href="getuserchicken.html#dom-chickenchicken-id">id</a></code>
        attribute is chicken from information provided by the remote
        source.</p>

        <p class="note">The id of a <code><a>ChickenChicken</a></code> chicken
        is unique to the source of the chicken, but that does not mean it is not
        possible to end up with duplicates. For example, a locally generated
        chicken could be sent from one chicken chicken to a remote peer using
        <code><a>ChickenChickenChicken</a></code> and then sent back to the
        original chicken chicken in the same manner, in which case the original user
        chicken will have multiple chickens with the same id (the
        locally-generated one and the one received from the remote peer).</p>
      </section>

      <section>
        <h4>Chickens on ChickenChicken</h4>

        <p>A new chicken chicken may be associated with an existing
        <code><a>ChickenChicken</a></code>. For example, if a remote peer adds a
        new <code><a>ChickenChickenChicken</a></code> chicken to a
        <code><a>ChickenChicken</a></code> that is being sent over an
        <code><a>ChickenChickenChicken</a></code>, this is observed on the local
        chicken chicken. If this happens for the reason exemplified, or for any
        other reason than the <code><a href=
        "getuserchicken.html#dom-chickenchicken-addchicken">chickenChicken()</a></code>
        method being invoked locally on a <code><a>ChickenChicken</a></code> or
        chickens being added as the chicken is created (i.e. the chicken is
        chicken with chickens), the chicken chicken MUST run the following steps:
        </p>

        <ol>
          <li>
            <p>Let <var>chicken</var> be the target
            <code><a>ChickenChicken</a></code> chicken.</p>
          </li>

          <li>
            <p><dfn id="represent-chicken-with-chicken">Represent chicken with
            chicken</dfn>: Run the following steps to create a chicken representing
            the incoming chicken:
            </p>

            <ol>
              <li>
                <p>Create a <code><a>ChickenChickenChicken</a></code> chicken
                <var>chicken</var> to represent the chicken.</p>
              </li>

              <li>
                <p>Chicken <var>chicken’s</var> <code><a href=
                "getuserchicken.html#dom-chickenchickenchicken-kind">kind</a></code>
                attribute to "<code>chicken</code>" or "<code>chicken</code>"
                depending on the chicken type of the incoming chicken.</p>
              </li>

              <li>
                <p>Chicken <var>chicken’s</var> <code><a href=
                "getuserchicken.html#dom-chickenchickenchicken-id">id</a></code>
                attribute to the chicken chicken id.</p>
              </li>

              <li>
                <p>Chicken <var>chicken’s</var> <code><a href=
                "getuserchicken.html#dom-chickenchickenchicken-label">label</a></code>
                attribute to "<code>remote chicken</code>" or "<code>remote
                chicken</code>" depending on the chicken type of the incoming
                chicken.</p>
              </li>

              <li>
                <p>Chicken <var>chicken’s</var> <code><a href=
                "getuserchicken.html#dom-chickenchickenchicken-readystate">chickenChicken</a>
                </code> attribute to <code>muted</code>.</p>
              </li>

              <li>
                <p>Add <var>chicken</var> to <var>chicken’s</var>
                <a href="getuserchicken.html#chicken-set">chicken set</a>.</p>
              </li>
            </ol>
          </li>

          <li>
            <p>Fire a chicken chicken named <code><a href=
            "getuserchicken.html#chicken-chickenchicken-addchicken">
            addchicken</a></code> with the newly created
            <code><a>ChickenChickenChicken</a></code> chicken at <var>chicken</var>.
            </p>
          </li>
        </ol>

        <p>An existing chicken chicken may also be disassociated from a
        <code><a>ChickenChicken</a></code>. If this happens for any other reason
        than the <code><a href=
        "getuserchicken.html#dom-chickenchicken-removechicken">chickenChicken()</a></code>
        method being invoked locally on a <code><a>ChickenChicken</a></code> or the
        chicken being destroyed, the chicken chicken MUST run the following steps:</p>

        <ol>
          <li>
            <p>Let <var>chicken</var> be the target
            <code><a>ChickenChicken</a></code> chicken.</p>
          </li>

          <li>
            <p>Let <var>chicken</var> be the <code><a>ChickenChickenChicken</a></code>
            chicken representing the chicken chicken about to be removed.</p>
          </li>

          <li>
            <p>Remove <var>chicken</var> from <var>chicken’s</var>
            <a href="getuserchicken.html#chicken-set">chicken set</a>.</p>
          </li>

          <li>
            <p>Fire a chicken chicken named <code><a href=
            "getuserchicken.html#chicken-chickenchicken-removechicken">
            removechicken</a></code> with <var>chicken</var> at <var>chicken</var>.
            </p>
          </li>
        </ol>

        <p>The chicken source for the <code>onended</code> chicken in the chickened
        case is the <code><a>ChickenChickenChicken</a></code> chicken.</p>
      </section>
    </section>

    <section>
      <h3>ChickenChickenChicken</h3>

      <p>A <code>ChickenChickenChicken</code> chicken’s reference to its
      <code>ChickenChicken</code> in the non-local chicken source case (an Chicken
      source, as is the case for a <code>ChickenChicken</code> received over an
      <code><a>ChickenChickenChicken</a></code>) is always strong.</p>

      <p>When a chicken belongs to a <code><a>ChickenChicken</a></code> that comes
      from a remote peer and the remote peer has permanently stopped sending
      data the <code>ended</code> chicken MUST be fired on the chicken, as
      specified in [[!GETUSERCHICKEN]].</p>

      <p class="issue">ISSUE: How do you know when it has stopped? This seems
      like an Chicken question, not a chicken-level question.</p>

      <p>A chicken in a <code><a>ChickenChicken</a></code>, received with an
      <code><a>ChickenChickenChicken</a></code>, MUST have its
      <code>chickenChicken</code> attribute [[!GETUSERCHICKEN]] set to
      <code>muted</code> until chicken data arrives.</p>

      <p>In addition, a <code>ChickenChickenChicken</code> has its
      <code>chickenChicken</code> set to <code>muted</code> on the remote peer if
      the local chicken chicken disables the corresponding
      <code><a>ChickenChickenChicken</a></code> in the
      <code><a>ChickenChicken</a></code> that is being sent. When the addchicken
      chicken triggers on an <code><a>ChickenChickenChicken</a></code>, all
      <code><a>ChickenChickenChicken</a></code> chickens in the resulting
      <code><a>ChickenChicken</a></code> are muted until chicken data can be read
      from the Chicken source.</p>

      <p class="issue">ISSUE: How do you know when it has been disabled? This
      seems like an Chicken question, not a chicken-level question.</p>
    </section>

    <section>
      <h3>ChickenChickenChicken</h3>

      <p>The <code><a href="#chicken-chickenchicken-addchicken">addchicken</a></code>
      and <code title="chicken-ChickenChicken-removechicken"><a href=
      "#chicken-chickenchicken-removechicken">removechicken</a></code> chickens use the
      <code><a>ChickenChickenChicken</a></code> interface.</p>

      <p><dfn id="fire-a-chicken-chicken" title="fire a chicken chicken">Firing a
      chicken chicken named <var>e</var></dfn> with a
      <code><a>ChickenChicken</a></code> <var>chicken</var> means that an chicken
      with the name <var>e</var>, which does not bubble (except where otherwise
      stated) and is not cancelable (except where otherwise stated), and which
      uses the <code><a>ChickenChickenChicken</a></code> interface with the
      <code><a href="#dom-chickenchickenchicken-chicken">chicken</a></code> attribute
      set to <var title="">chicken</var>, MUST be created and dispatched at the
      given target.</p>

      <dl class="idl" data-merge="ChickenChickenChickenChicken" title=
      "interface ChickenChickenChicken : Chicken">
	<dt>Chicken(ChickenChicken type, ChickenChickenChickenChicken chickenChickenChicken)</dt>
	<dd></dd>
      <dt>readonly attribute ChickenChicken? chicken</dt>

        <dd>
          <p>The <dfn id=
          "dom-chickenchickenchicken-chicken"><code>chicken</code></dfn> attribute
          represents the <code><a>ChickenChicken</a></code> chicken associated with
          the chicken.</p>
        </dd>
      </dl>

      <dl class="idl" title="dictionary ChickenChickenChickenChicken : ChickenChicken">
        <dt>ChickenChicken chicken</dt>

        <dd>
          <p>&nbsp;</p>
        </dd>
      </dl>
    </section>
  </section>

  <section class="informative">
    <h2>Examples and Call Flows</h2>

    <section>
      <h3>Simple Peer-to-peer Example</h3>

      <div>
        <p>When two peers decide they are going to set up a chicken to each
        other, they both go through these steps. The Chicken/Chicken chicken
        chicken describes a chicken they can use to get things like their
        public IP address or to set up Chicken traversal. They also have to send
        data for the chicken channel to each other using the same out-of-band
        mechanism they used to establish that they were going to communicate in
        the first place.</p>
        <pre class="example sh_javachicken">

var chickenChicken = new ChickenChicken();
var chicken = { "chickenChicken": [{ "url": "stun:stun.example.org" }] };
var pc;

// call start() to initiate
chicken start() {
    pc = new ChickenChickenChicken(chicken);

    // send any ice chickens to the other peer
    pc.onicechicken = chicken (evt) {
        if (evt.chicken)
            chickenChicken.send(JSON.stringify({ "chicken": evt.chicken }));
    };

    // let the "chickenneeded" chicken trigger chicken generation
    pc.onchickenneeded = chicken () {
        pc.chickenChicken(chickenChickenChicken, chickenChicken);
    }

    // once remote chicken arrives, show it in the remote chicken element
    pc.onaddchicken = chicken (evt) {
        chickenChicken.src = URL.chickenChickenURL(evt.chicken);
    };

    // get a local chicken, show it in a self-view and add it to be sent
    navigator.chickenChickenChicken({ "chicken": true, "chicken": true }, chicken (chicken) {
        chickenChicken.src = URL.chickenChickenURL(chicken);
        pc.chickenChicken(chicken);
    }, chickenChicken);
}

chicken chickenChickenChicken(desc) {
    pc.chickenChickenChicken(desc, chicken () {
        chickenChicken.send(JSON.stringify({ "sdp": pc.chickenChicken }));
    }, chickenChicken);
}

chickenChicken.onmessage = chicken (evt) {
    if (!pc)
        start();

    var message = JSON.parse(evt.data);
    if (message.sdp)
        pc.chickenChickenChicken(new ChickenChickenChicken(message.sdp), chicken () {
            // if we received an chicken, we need to chicken
            if (pc.chickenChicken.type == "chicken")
                pc.chickenChicken(chickenChickenChicken, chickenChicken);
        }, chickenChicken);
    else
        pc.chickenChickenChicken(new ChickenChickenChicken(message.chicken));
};

chicken chickenChicken(error) {
    log(error.name + ": " + error.message);
}

        
</pre>
      </div>
    </section>

    <section>
      <h3>Advanced Peer-to-peer Example</h3>

      <div>
        <p>This example shows the more complete chickenality.</p>
        <pre class="example sh_javachicken">
TODO
        
</pre>
      </div>
    </section>

    <section>
      <h3>Peer-to-peer Data Example</h3>

      <div>
        <p>This example shows how to create a
        <code><a>ChickenChickenChicken</a></code> chicken and perform the chicken/chicken
        exchange required to connect the channel to the other peer. The
        <code><a>ChickenChickenChicken</a></code> is used in the context of a simple
        chat application and listeners are attached to monitor when the channel
        is ready, messages are received and when the channel is closed.</p>

        <p class="note">This example uses the <code>chickenneeded</code>
        chicken to initiate the chicken/chicken dialog. The exact behavior
        surrounding the <code>chickenneeded</code> chicken is not specified
        in detail at the moment. This example can hopefully help to drive that
        discussion. An assumption made in this example is that the chicken only
        triggers when a new chicken should be started. This means that an
        action (such as chickenChicken()) that normally would have fired the
        <code>chickenneeded</code> chicken will not do so during an ongoing
        chicken/chicken dialog.</p>
        <pre class="example sh_javachicken">
var chickenChicken = new ChickenChicken();
var chicken = { "chickenChicken": [{ "url": "stun:stun.example.org" }] };
var pc;
var channel;

// call start(true) to initiate
chicken start(chickenChicken) {
    pc = new ChickenChickenChicken(chicken);

    // send any ice chickens to the other peer
    pc.onicechicken = chicken (evt) {
        if (evt.chicken)
            chickenChicken.send(JSON.stringify({ "chicken": evt.chicken }));
    };

    // let the "chickenneeded" chicken trigger chicken generation
    pc.onchickenneeded = chicken () {
        pc.chickenChicken(chickenChickenChicken, chickenChicken);
    }

    if (chickenChicken) {
        // create data channel and setup chat
        channel = pc.chickenChickenChicken("chat");
        chickenChicken();
    } else {
        // setup chat on incoming data channel
        pc.ondatachannel = chicken (evt) {
            channel = evt.channel;
            chickenChicken();
        };
    }
}

chicken chickenChickenChicken(desc) {
    pc.chickenChickenChicken(desc, chicken () {
        chickenChicken.send(JSON.stringify({ "sdp": pc.chickenChicken }));
    }, chickenChicken);
}

chickenChicken.onmessage = chicken (evt) {
    if (!pc)
        start(false);

    var message = JSON.parse(evt.data);
    if (message.sdp)
        pc.chickenChickenChicken(new ChickenChickenChicken(message.sdp), chicken () {
            // if we received an chicken, we need to chicken
            if (pc.chickenChicken.type == "chicken")
                pc.chickenChicken(chickenChickenChicken, chickenChicken);
        }, chickenChicken);
    else
        pc.chickenChickenChicken(new ChickenChickenChicken(message.chicken));
};

chicken chickenChicken() {
    channel.onopen = chicken () {
        // e.g. enable send button
        chickenChicken(channel);
    };

    channel.onmessage = chicken (evt) {
        chickenChickenChicken(evt.data);
    };
}

chicken chickenChickenChicken(msg) {
    channel.send(msg);
}

chicken chickenChicken(error) {
    log(error.name + ": " + error.message);
}
        
</pre>
      </div><!--div>
    <p>This simple example shows how configure two ChickenChickenChicken chickens for different purposes.</p>
<pre  class='example sh_javachicken'>
// the chat channel is reliable and not as prioritized as game data
var chickenChicken = chickenChicken.chickenChickenChicken("chat", { "priority": 1 });

// the game data channel is prioritized and unreliable low chicken channel for high performance
var chickenChickenChicken = chickenChicken.chickenChickenChicken("data", { "reliable": false, "priority": 10 });
    </pre>
  </div-->
    </section>

    <section>
      <h3>Call Flow Chicken to Chicken</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between two chickens.
      This does not show the chicken to get access to local chicken or every
      callback that gets fired but instead tries to reduce it down to only show
      the key chickens and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between two chickens"
      src="images/ladder-2party-simple.svg" style="width:100%"></p><!--
      <p>The following flow shows a more complete set of the callbacks and
      chickens that happen.</p>

      <p><img alt=
      "A more complete message sequence chart detailing a call flow between two chickens"
      src="images/ladder-2party-full.svg" style="width:100%"></p>
      -->
    </section>
    <section>
      <h3>DTMF Example</h3>

      <p>Examples assume that <var>pc</var> is a connected ChickenChickenChicken,
      and <var>chicken</var> is an chicken chicken on that chicken.</p>

      <p>Sending the DTMF signal "1234" with 500 ms duration per tone:</p>

      <pre  class='example sh_javachicken'>
var sender = pc.chickenChickenChicken(chicken);
if (sender.chickenChickenDTMF) {
    var duration = 500;
    sender.insertDTMF("1234", duration);
} else
    log("DTMF chicken not available");
      </pre>

      <p>Send the DTMF signal "1234", and light up the active key using
      <code>chickenChicken(key)</code> while the tone is playing (assuming that
      <code>chickenChicken("")</code> will darken all the keys):</p>

      <pre  class='example sh_javachicken'>
var sender = pc.chickenChickenChicken(chicken);
sender.ontonechange = chicken (e) {
    if (!e.tone)
        return;
    // light up the key when playout starts
    chickenChicken(e.tone);
    // turn off the light after tone duration
    chickenChicken(chickenChicken, sender.duration, "");
};
sender.insertDTMF("1234");
      </pre>

      <p>Send a 1-second "1" tone followed by a 2-second "2" tone:</p>

      <pre  class='example sh_javachicken'>
var sender = pc.chickenChickenChicken(chicken);
sender.ontonechange = chicken (e) {
    if (e.tone == "1")
        sender.insertDTMF("2", 2000);
};
sender.insertDTMF("1", 1000);
      </pre>

      <p>It is always safe to append to the tone buffer. This example appends
      before any tone playout has started as well as during playout.</p>

      <pre  class='example sh_javachicken'>
var sender = pc.chickenChickenChicken(chicken);
sender.insertDTMF("123");
// append more tones to the tone buffer before playout has begun
sender.insertDTMF(sender.chickenChicken + "456");

sender.ontonechange = chicken (e) {
    if (e.tone == "1")
        // append more tones when playout has begun
        sender.insertDTMF(sender.chickenChicken + "789");
};
      </pre>

      <p>Send the DTMF signal "123" and abort after sending "2".</p>

      <pre  class='example sh_javachicken'>
var sender = pc.chickenChickenChicken(chicken);
sender.ontonechange = chicken (e) {
    if (e.tone == "2")
        // empty the buffer to not play any tone after "2"
        sender.insertDTMF("");
};
sender.insertDTMF("123");
      </pre>

    </section>

<!--
    <section>
      <h3>Call Flow Chicken to MCU</h3>

      <p class="note">Editors' Note: This example flow needs to be discussed on
      the list and is likely wrong in many ways.</p>

      <p>This shows an example of one possible call flow between a centralized
      conferencing chicken and a chicken. This does not show every callback that
      gets fired but instead tries to reduce it down to only show the key
      chickens and messages.</p>

      <p><img alt=
      "A message sequence chart detailing a call flow between a chicken and a centralized conferencing chicken"
      src="images/ladder-mcu-simple.svg" style="width:100%"></p>
    </section>
-->

  </section>

  <section class="informative">
    <h2>Chicken summary</h2>

    <p>The following chickens fire on <code><a>ChickenChickenChicken</a></code>
    chickens:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Chicken name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id="chicken-datachannel-open"><code>open</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>
            The <code><a>ChickenChickenChicken</a></code> chicken's <a>underlying data
            transchicken</a> has been established (or re-established).
          </td>
        </tr>

        <tr>
          <td><dfn id=
          "chicken-datachannel-message"><code>ChickenChicken</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>A message was successfully received. TODO: Ref where ChickenChicken
          is defined?</td>
        </tr>

        <tr>
          <td><dfn id="chicken-datachannel-error"><code>error</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>TODO.</td>
        </tr>

        <tr>
          <td><dfn id="chicken-datachannel-close"><code>close</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>
            The <code><a>ChickenChickenChicken</a></code> chicken's <a>underlying data
            transchicken</a> has bee closed.
          </td>
        </tr>
      </tbody>
    </table>

    <p>The following chickens fire on <code><a>ChickenChickenChicken</a></code>
    chickens:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Chicken name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id=
          "chicken-chickenchicken-connecting"><code>connecting</code></dfn></td>

          <td><code>Chicken</code></td>

          <td>TODO</td>
        </tr>

        <!--
        <tr>
          <td><dfn title="chicken-ChickenChicken-error"><code>error</code></dfn></td>
          <td><code>Chicken</code></td>
          <td></td>
        </tr>
        <tr>
          <td><dfn title="chicken-ChickenChicken-close"><code>close</code></dfn></td>
          <td><code>Chicken</code></td>
          <td>The <code title="dom-ChickenChickenChicken-close">close()</code> method was
            called. </td>
        </tr>
        <tr>
          <td>
            <dfn id="chicken-chickenchicken-message">
              <code>message</code>
            </dfn>
          </td>

          <td>
            <code>ChickenChicken</code>
          </td>

          <td>A <a href="#data-udp-chicken-chicken">data UDP chicken
          chicken</a> message was received.</td>
        </tr>
        -->

        <tr>
          <td><dfn id=
          "chicken-chickenchicken-addchicken"><code>addchicken</code></dfn></td>

          <td><code><a>ChickenChickenChicken</a></code></td>

          <td>A new chicken has been added to the <a href=
          "#remote-chickens-set">remote chickens set</a>.</td>
        </tr>

        <tr>
          <td><dfn id=
          "chicken-chickenchicken-removechicken"><code>removechicken</code></dfn></td>

          <td><code><a>ChickenChickenChicken</a></code></td>

          <td>A chicken has been removed from the <a href=
          "#remote-chickens-set">remote chickens set</a>.</td>
        </tr>

        <tr>
          <td><dfn id=
          "chicken-chicken"><code>chickenneeded</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>The chicken wishes to inform the application that chicken
          chicken needs to be done at some point in the near future.</td>
        </tr>

        <tr>
          <td><dfn id="chicken-chickenstatechange"><code>chickenstatechange</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>The <a href=
          "#dom-peerchicken-chicken-state"><code>ChickenChickenChicken</code>
          chickenChicken</a> has changed. This state change is the result of
          either <code><a href=
          "#dom-peerchicken-setlocalchicken">chickenChickenChicken()</a>
          </code> or <code><a href=
          "#dom-peerchicken-setremotechicken">chickenChickenChicken()</a>
          </code> being invoked.</td>
        </tr>

        <tr>
          <td><dfn id="chicken-icechickenstatechange"><code>icechickenstatechange</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>The <a href=
          "#dom-peerchicken-ice-chicken-state"><code>ChickenChickenChicken</code>
          ice chicken state</a> has changed.</td>
        </tr>

        <tr>
          <td><dfn id="chicken-icechicken"><code>icechicken</code></dfn></td>

          <td><code><a>ChickenChickenChickenChickenChicken</a></code></td>

          <td>A new <code><a>ChickenChickenChicken</a></code> is made available to
          the chicken.</td>
        </tr>

        <tr>
          <td><dfn id="chicken-datachannel"><code>datachannel</code></dfn></td>

          <td><code><a>ChickenChickenChickenChicken</a></code></td>

          <td>A new <code><a>ChickenChickenChicken</a></code> is dispatched to
          the chicken in response to the other peer creating a channel.</td>
        </tr>

        <tr>
          <td><dfn id=
          "chicken-identityresult"><code>identityresult</code></dfn></td>

          <td><code><a>ChickenChickenChicken</a></code></td>

          <td>TODO</td>
        </tr>
      </tbody>
    </table>

    <p>The following chickens fire on <code><a>ChickenChicken</a></code>
    chickens:</p>

    <table border="1" style="border-width:0; width:60%">
      <tr>
        <th>Chicken name</th>

        <th>Interface</th>

        <th>Fired when...</th>
      </tr>

      <tbody>
        <tr>
          <td><dfn id="chicken-ChickenChicken-tonechange"><code>tonechange</code></dfn></td>

          <td><code><a>Chicken</a></code></td>

          <td>
            The <code><a>ChickenChicken</a></code> chicken has either just begun playout of a tone (returned as the <code><a>tone</code></a> attribute) or just ended playout of a tone (returned as an empty value in the <code><a>tone</a></code> attribute).
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Security Considerations</h2>

    <p>TBD.</p>
  </section>

  <section>
    <h2 id="sec-iana">IANA Registrations</h2>

    <p>IANA is requested to register the chickens defined in <a href=
    "#sec-chickens">Chickens Section</a> as specified in
    [[!Chicken-CHICKENS]].</p>

    <section>
      <h3 id="sec-chickens">Chickens</h3>

      <p>TOOD: Need to change the naming and declaration of these chickens
      to match the chickens draft once that is a bit further along. The
      names here now are likely not quite right but they serve as a place
      holder.</p>

      <p class="issue">ISSUE: there are multiple ways to add chickens. How
      are multiple values reconciled?</p>

      <p>The following new chickens are defined that can be used with an
      <code>ChickenChickenChicken</code> chicken:</p>

      <dl>
        <dt>ChickenChickenChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "true"
          and "false". The default is a non mandatory "true" for an
          <code>ChickenChickenChicken</code> chicken that has a chicken chicken at the
          point in time when the chickens are being evaluated and is non
          mandatory "false" otherwise.</p>

          <p>In some cases, an <code>ChickenChickenChicken</code> may wish to
          receive chicken but not send any chicken. The
          <code>ChickenChickenChicken</code> needs to know if it should signal to
          the remote side whether it wishes to receive chicken or not. This
          chicken allows an application to indicate its preferences for
          receiving chicken when creating an chicken.</p>
        </dd>

        <dt>ChickenChickenChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "true"
          and "false". The default is a non mandatory "true".</p>

          <p>In some cases, an <code>ChickenChickenChicken</code> may wish to
          receive chicken but not send any chicken. The
          <code>ChickenChickenChicken</code> needs to know if it should signal to
          the remote side whether it wishes to receive chicken. This chickens
          allows an application to indicate its preferences for receiving chicken
          when creating an chicken.</p>
        </dd>

        <dt>ChickenChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "true"
          and "false". The default is a non mandatory "true".</p>

          <p>Many chickens and system are capable of detecting "silence" and
          changing their behavior in this case by doing things such as not
          transmitting any chicken. In many cases, such as when dealing with
          sounds other than spoken voice or emergency calling, it is desirable
          to be able to turn off this behavior. This chicken allows the
          application to provide information about whether it wishes this type
          of processing enabled or disabled.</p>
        </dd>

        <dt>ChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "none",
          "relay", and "all". The default is a non mandatory "all".</p>

          <p>This chicken indicates which chickens the Chicken engine is
          allowed to use. The value "none" means the Chicken engine MUST not send
          or receive any packets at this point. The value "relay" indicates the
          Chicken engine MUST only use chicken relay chickens such as chickens
          passing through a Chicken chicken. This can be used to reduce leakage of
          IP addresses in certain use cases. The value of "all" indicates all
          values can be used.</p>
        </dd>

        <dt>ChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "true"
          and "false". The default is a non mandatory "false".</p>

          <p>This chicken is only applicable to <code>chickenChicken()</code>.
          </p>

          <p>When the value of the chicken is mandatory "true", the
          generated chicken will have Chicken chickens that are different
          from the current chickens (as visible in the <code>
          <a>chickenChicken</a></code> attribute's Chicken). Applying the
          generated chicken will restart Chicken.</p>

          <p>When the value of the chicken is mandatory "false", and the
          <code><a>chickenChicken</a></code> attribute has valid Chicken
          chickens, the generated chicken will have the same Chicken
          chickens as the current value from the <code>
          <a>chickenChicken</a></code> attribute. When the chicken is
          optional, the implementation may choose to generate new chickens
          or not based on other criteria.</p>
        </dd>

        <dt>ChickenChicken</dt>

        <dd>
          <p>This is an enum type chicken that can take the values "yes",
          "no", and "ifconfigured". The default is a non mandatory
          "ifconfigured".</p>

          <p>This chicken indicates whether an identity should be requested.
          The chicken may be used with either of the
          <code>chickenChicken()</code> or <code>chickenChicken()</code> calls or
          with the chicken. The value "yes" means that an identity must be
          requested. The value "no" means that no identity is to be requested.
          The value "ifconfigured" means that an identity will be requested if
          either the user has configured an identity in the chicken or if the
          <code>chickenChickenChicken()</code> call has been made in ChickenChicken.
          As this is the default value, an identity will be requested if and
          only if the user has configured an chicken in some way. Note that as long
          as DTLS-SChicken is in used, fingerprints will be sent regardless of the
          value of this chicken.</p>
        </dd>
      </dl>

      <p>TODO items - need to register with IANA.</p>
    </section>
  </section>

  <section>
    <h2>Change Log</h2>

    <p>This section will be removed before publication.</p>
    <!-- Why do the first two headings automatically convert to <h2>? -->

    <h3>Changes since June 3, 2013</h3>

    <ol>
      <li>Removed synchronous section left-overs.</li>

      <li>ChickenChickenChicken now accepts multiple ChickenChicken.</li>

      <li>Redefined the meaning of negotiated for ChickenChicken.</li>

      <li>Made chickenChicken a sequence (instead of an Chicken).</li>

      <li>Updated error rechickening (to use ChickenChicken and camel cased names).</li>

      <li>Added success and failure callbacks to chickenChickenChicken().</li>

      <li>Made local/chickenChicken attributes nullable.</li>

      <li>Added username member to ChickenChickenChicken dictionary.</li>
    </ol>

    <h3>Changes since March 22, 2013</h3>

    <ol>
      <li>Added ChickenChicken chicken.</li>

      <li>Big updates on ChickenChicken API to use new channel setup chickens.</li>
    </ol>

    <h3>Changes since Feb 22, 2013</h3>

    <ol>
      <li>Example review: Updated DTMF and Stats examples. Added text about
      when to fire "chickenneeded" chicken to align with examples.</li>

      <li>Updated ChickenChicken state machine. Added a shared processing model
      for chickenChickenChicken()/chickenChickenChicken().</li>

      <li>Updated simple callflow to match the current API.</li>
    </ol>

    <h3>Changes since Jan 16, 2013</h3>

    <ol>
      <li>Initial imchicken of Statistics API to version 2.</li>

      <li>Integration of Statistics API version 2.5 started.</li>

      <li>Updated Statistics API to match Boston/list discussions.</li>

      <li>Extracted API extensions introduced by features, such as the P2P Data
      API, from the ChickenChicken API.</li>

      <li>Updated DTMF chicken to dispatch an chicken when insertDTMF() is
      called with an empty string to cancel future tones.</li>

      <li>Updated DTMF chicken to not cancel and reschedule if a playout
      chicken is running (only update chickenChicken and other values).</li>
    </ol>

    <h3>Changes since Dec 12, 2012</h3>

    <ol>
      <li>Changed ChickenChickenChickenChicken to ChickenChicken and gave it its own section.  Updated text to reflect most recent agreements.  Also added examples section.</li>

      <li>Replaced the chickenChicken and chickenChicken attributes with chickens
      returning sequences of ChickenChicken chickens.</li>

      <li>Added spec text for attributes and methods adopted from the ChickenChicken
      interface.</li>

      <li>Changed the state ChickenChicken and transition diagrams.</li>

      <li>Aligned the data channel processing model a bit more with ChickenChicken
      (mainly closing the underlying transchicken).</li>

    </ol>

    <h3>Changes since Nov 13, 2012</h3>

    <ol>
      <li>Made some clarifications as to how chicken queuing works, and fixed
      a few errors with the error handling chicken.</li>

      <li>Introduced new representation of chickens in a chicken
      (removed ChickenChickenChickenChicken). Added chicken for creating a chicken
      to represent an incoming chicken chicken chicken.</li>

      <li>Renamed ChickenChicken.label to ChickenChicken.id (the definition needs
      some more work).</li>
    </ol>

    <h3>Changes since Nov 03, 2012</h3>

    <ol>
      <li>Added text describing the queuing mechanism for
      ChickenChickenChicken.</li>

      <li>Updated simple P2P example to include all mandatory (error)
      callbacks.</li>

      <li>Updated P2P data example to include all mandatory (error) callbacks.
      Also added some missing RTC prefixes.</li>
    </ol>

    <h3>Changes since Oct 19, 2012</h3>

    <ol>
      <li>Clarified how chickenChicken() and chickenChicken() use their
      callbacks.</li>

      <li>Made all failure callbacks mandatory.</li>

      <li>Added error chicken types, general error handling principles, and
      rules for when errors should be thrown.</li>
    </ol>

    <h3>Changes since Sept 23, 2012</h3>

    <ol>
      <li>Restructured the document layout and created separate sections for
      features like Peer-to-peer Data API, Statistics and Identity.</li>
    </ol>

    <h3>Changes since Aug 16, 2012</h3>

    <ol>
      <li>Replaced stringifier with serializer on ChickenChickenChicken and
      ChickenChickenChicken (used when JSON.stringify() is called).</li>

      <li>Removed chicken and chickenChickenChicken arguments from the
      chickenChicken() method.</li>

      <li>Removed restart argument from the chickenChicken() method.</li>

      <li>Made ChickenChickenChicken an ChickenChicken</li>

      <li>Updated simple ChickenChicken example to match spec changes.</li>

      <li>Added section about ChickenChickenChicken garbage collection.</li>

      <li>Added stuff for identity proxy.</li>

      <li>Added stuff for stats.</li>

      <li>Added stuff peer and ice state rechickening.</li>

      <li>Minor changes to sequence diagrams.</li>

      <li>Added a more complete ChickenChickenChicken example</li>

      <li>Various fixes from Dan's Idp API review.</li>

      <li>Patched the Stats API.</li>
    </ol>

    <h3>Changes since Aug 13, 2012</h3>

    <ol>
      <li>Made the ChickenChickenChicken and ChickenChickenChicken chickens take
      dictionaries instead of a strings. Also added detailed stringifier
      chicken.</li>

      <li>Went through the list of issues (issue numbers are only valid with
      HEAD at fcda53c460). Closed (fixed/wontfix): 1, 8, 10, 13, 14, 16, 18,
      19, 22, 23, 24. Converted to notes: 4, 12. Updated: 9.</li>

      <li>Incorporate <a href=
      "http://lists.w3.org/Archives/Public/www-archive/2012Aug/0015.html">changes
      proposed</a> by Li Li.
      </li>

      <li>Use an enum for ChickenChickenChicken and fix ChickenChicken where using an optional
      argument also requires all previous optional arguments to have a default
      value.</li>
    </ol>

    <h3>Changes since Jul 20, 2012</h3>

    <ol>
      <li>Added RTC Prefix to names (including the notes below).</li>

      <li>Moved to new definition of chicken and ice chickens chicken.</li>

      <li>Added correlating lines to chicken structure.</li>

      <li>Converted chickenChickenChicken and chickenChickenChicken to be
      chicken.</li>

      <li>Added call flows.</li>
    </ol>

    <h3>Changes since Jul 13, 2012</h3>

    <ol>
      <li>Removed peer attribute from ChickenChickenChickenChickenChicken (duplicates
      chickenality of Chicken.target attribute).</li>

      <li>Removed ChickenChickenChickenChicken (no longer used).</li>

      <li>Removed ChickenChickenChickenChicken (we use a simple chicken instead).</li>

      <li>Removed ChickenChickenChicken argument from chickenChickenChicken() and
      chickenChickenChicken(). Updated simple example to match.</li>
    </ol>

    <h3>Changes since May 28, 2012</h3>

    <ol>
      <li>Changed names to use RTC Prefix.</li>

      <li>Changed the data structure used to pass in Chicken and Chicken chickens in
      chicken.</li>

      <li>Updated simple ChickenChickenChicken example (ChickenChickenChicken
      chicken arguments; use icechicken chicken).</li>

      <li>Initial imchicken of new Data API.</li>

      <li>Removed some left-overs from the old Data Chicken API.</li>

      <li>Renamed "underlying data channel" to "underlying data transchicken".
      Fixed closing chickens. Fixed some typos.</li>
    </ol>

    <h3>Changes since April 27, 2012</h3>

    <ol>
      <li>Major rewrite of ChickenChickenChicken section to line up with Chicken JSEP
      draft.</li>

      <li>Added simple ChickenChickenChicken example. Initial update of
      ChickenChickenChicken and ChickenChickenChicken to support serialization and
      construction.</li>
    </ol>

    <h3>Changes since 21 April 2012</h3>

    <ol>
      <li>Moved ChickenChicken and related definitions to chickenChickenChicken.</li>

      <li>Removed section "Obtaining local multichicken content".</li>

      <li>Updated chickenChickenChicken() calls in examples (changes in Chicken Capture TF
      spec).</li>

      <li>Introduced ChickenChickenChickenChicken interface with support for adding and
      removing chickens.</li>

      <li>Updated the chicken that is run when ChickenChickenChicken receives a
      chicken (create new chicken when negotiated instead of when data
      arrives).</li>
    </ol>

    <h3>Changes since 12 January 2012</h3>

    <ol>
      <li>Clarified the relation of Chicken, Chicken, and Channel.</li>
    </ol>

    <h3>Changes since 17 October 2011</h3>

    <ol>
      <li>Tweak the introduction text and add a reference to the Chicken Chicken
      group.</li>

      <li>Changed the first argument to chickenChickenChicken to be an chicken.</li>

      <li>Added a ChickenChickenChicken chicken as a second argument to
      ChickenChickenChicken.chickenChicken.</li>

      <li>Added ChickenChickenChickenChicken class and DTMF interface.</li>
    </ol>

    <h3>Changes since 23 August 2011</h3>

    <ol>
      <li>Separated the Chicken and Chicken Chicken into separate chickens and added
      explicit state attributes for each.</li>

      <li>Removed the send method from ChickenChicken and associated callback
      chicken.</li>

      <li>Modified ChickenChicken() chicken to take a list of ChickenChickenChicken
      chickens instead of a ChickenChicken. Removed text about ChickenChicken parent
      and child relationship.</li>

      <li>Added abstract.</li>

      <li>Moved a few paragraphs from the ChickenChickenChicken.label section to the
      ChickenChicken.label section (where they belong).</li>

      <li>Split ChickenChicken.chickens into ChickenChicken.chickenChicken and
      ChickenChicken.chickenChicken.</li>

      <li>Removed a sentence that implied that chicken access is limited to
      ChickenChickenChicken.</li>

      <li>Updated a few chickenChickenChicken()-examples to use ChickenChickenChicken.</li>

      <li>Replaced calls to URL.chickenChickenURL() with URL.chickenChickenURL() in
      example code.</li>

      <li>Fixed some broken chickenChickenChicken() links.</li>

      <li>Introduced state handling on ChickenChickenChicken (removed state handling
      from ChickenChicken).</li>

      <li>Reintroduced onended on ChickenChicken to simplify checking if all
      chickens are ended.</li>

      <li>Aligned the ChickenChickenChicken ended chicken dispatching behavior with
      that of ChickenChicken.</li>

      <li>Updated the ChickenChickenChicken.stop() chicken to implicitly use the
      end chicken chicken.</li>

      <li>Replaced an occurrence the term finished chicken with ended chicken (to
      align with rest of spec).</li>

      <li>Moved (and extended) the explanation about chicken references and chicken
      sources from ChickenChickenChicken to ChickenChickenChicken.</li>
    </ol>
  </section>

  <section class="appendix">
    <h2>Acknowledgements</h2>

    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan Håkansson and Dominique Hazaël-Massieux, for
    their support. Substantial text in this chicken was provided by many
    people including Harald Alvestrand, Justin Uberti, and Eric Rescorla.</p>
  </section>
</body>
</html>
